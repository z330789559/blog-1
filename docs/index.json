[{"categories":null,"contents":"","date":"Nov 26","permalink":"http://blog.ibyte.me/projects/fw_project/","tags":null,"title":"falsework"},{"categories":null,"contents":"","date":"Nov 26","permalink":"http://blog.ibyte.me/projects/gsql_project/","tags":null,"title":"gsql"},{"categories":null,"contents":"","date":"Nov 26","permalink":"http://blog.ibyte.me/projects/s2s_project/","tags":null,"title":"s2s"},{"categories":null,"contents":"","date":"Nov 26","permalink":"http://blog.ibyte.me/projects/sessionx_project/","tags":null,"title":"sessionx"},{"categories":null,"contents":"本页面是本博主个人平时整理的一些计算机科学专业视频学习资料，整理放在下面方便大家浏览，希望对大家有帮助。\n   资料名称 链接     数据库基础 哔哩哔哩视频   数据结构基础 哔哩哔哩视频   操作系统基础 上海交通大学-陈海波    ","date":"Sep 24","permalink":"http://blog.ibyte.me/post/computer-science-learning/","tags":null,"title":"Computer Science Learning"},{"categories":null,"contents":"   概 述  在开发过程中，作为一个crud boy来说会使sql来操作数据库增删改查是必不可少的，这篇文章将写写日常开发中常用的sql语句。数据是一个抽象的的定义，所谓的数据库就是把一些元数据通过特定规律整理到一起管理起来，方便通过他特定DDL，DCL，DML这些特定的语句来方便管理数据。\n DDL (data definition languages) 方便开发者通过SQL来定义存储的数据格式，组织数据。 DML (data manipulation languages) 允许用户对数据进行create、delete、insert、updated操作。 DCL (data control languages) 可以来管理用户对数据的访问操作权限，例如检索，更新，删除 \u0026hellip;     查询语句  在日常开发过程中查询数据是应用场景最多的，查询就要使用select关键字，如下：\n1  select * from tableName;   例如有一个表结构如下：\n上面是查询整张表的所有字段数据，如果需要筛选就需要制定其field name如下：\n1  select name as \u0026#34;用户名\u0026#34; from TableName;   并且上面使用了as关键字并进行了别名，查询出来数据就按照别名进行展示。\n如果想查询指定的数据,就要使用where子语句，如下：\n1  select * from TableName where ID = 1;   那么上的SQL语句查询出来的结果就是上图中ID等于1的一条数据。\n如果需要整理结果集去重复的话在前面加入distinct关键字，就可以去重了。\n   查询过滤  有时候我们通过条件查询到的数据需要进行其他筛选，这个时候我们就要使用到limit或者order by进行过滤或者重新整理了。\n例如我要查询表中年龄最小那个用户的名字，这里不排除年龄是重复的情况，如下：\n1  select username from TableName order by age desc limit 1;   上面就是对 age进行降序然后取一条数据。\n1  select * from TableName order by age ASC;   对表进行按照age升序排序整理输出结果。\nlimit支持几种方式，limit 2,5意思是从第2行开始，往后查询5条数据，limit 2 offset 3意思是从3开始往后查询2条数据。\n有时候我们查询需要使用运算符，sql也是支持运算符的\u0026lt;、\u0026gt;、\u0026lt;\u0026gt;、\u0026lt;=、\u0026gt;=、!\u0026lt;、!\u0026gt;，这些都可以加在条件语句中。\n字段类型也支持数学运算例如：\n1  select * from TableName where (age+10) = 32;   上面一条语句就是查询age加10以后等于32的数据。\n有时候我们需要对这个表进行多个条件限制查询，我们可能就需要使用到OR或者AND进行条件关联查询了，例如：\n1 2 3 4  select users.mobile, user_address.mobile as \u0026#34;用户订单手机号\u0026#34;, user_address.address from user_address, users where user_address.user_id = users.user_id;   上面这个多表关联查询了，条件是user_address表的id要和users表的id相等的数据查询出来。\n多个条件可以使用and关联起来组成一个条件，例如：\n1  select BookName as 书名,Price as 价格, Writer AS 作者 from bookinfo WHERE MONTH(pDate)=9 and YEAR(pDate)=2021;   查询图书表里面的出版月份是9月的并且是2021年的9月出版的图书信息。\n1  select * from TableName where username = \u0026#39;Leon Ding\u0026#39; or age = 22;   上面使用or满足任意一边条件即可就能查询到数据。\n还有一种就是查询在某个范围内的数据，例如：\n1 2 3  select * from goods where cost_price between 1099 and 2880;   上面就是查询成本价在1099-2880之间的商品信息，我们还可以使用not放在between前面，也就是取反的意思。\n多个条件或者通过多个类型来查询可以使用in关键字，例如：\n1  select * from TableName age in (22,18);   上面是查年龄是22和18的用户信息。\n","date":"Sep 21","permalink":"http://blog.ibyte.me/post/often-used-structured-query-languages/","tags":null,"title":"Often Used Structured Query Languages"},{"categories":null,"contents":"相信大家在开发的过程中会去编写一些数据库表对应的model，工作比较重复并且低效，本文将介绍笔者写的一个工具可以根据数据库表生产对应的model逆向工程工具。\n   什么是s2s？  s2s (sql to structure)是一款命令行数据库逆向工程工具，它可以通过数据库表生成对应的Java、Go、Rust结构体（class），后面将陆续支持更多的语言。\n   配置数据库源  s2s依赖于你的数据库，所以需要你配置好你的数据库连接信息，以便s2s会正常的运行。配置信息方法很简单你只需要在你的环境变量中加入以下信息即可。\n推荐使用开发环境的下的root用户登录，因为工具需要information_schema表的权限。\n1 2 3 4 5  #s2s 命令的数据库信息 export s2s_host=\u0026#34;127.0.0.1:3306\u0026#34; export s2s_user=\u0026#34;root\u0026#34; export s2s_pwd=\u0026#34;you db password\u0026#34; export s2s_charset=\u0026#34;utf8\u0026#34;   windows的配置此电脑-\u0026gt;属性-\u0026gt;高级系统设置-\u0026gt;环境变量，Mac和Linux则在~/.profile或者~/.zshrc中添加以上配置信息即可。\n   使用方法    你可以克隆下载本代码库，然后如果你的电脑上已经安装好了go的编译器那么就进入主目录即可使用go build命令编译生成二进制程序文件。\n  如果你觉得麻烦即可在下面列表中找到你对应的平台架构下载对应的二进制可执行文件到电脑上，如果你想在系统上随意调用你则只需要把s2s的安装目录放入你的环境变量中。\n  目前对Rust部分数据类型支持不够友好，不过不耽误使用，目前被生成的数据库表名格式必须为user_info这样的snake case这种格式！！后面会考虑修复这个bug。\n     平台 地址     Windows-x64 s2s-windows-x64.zip   Mac-x64 s2s-darwin-x64.zip   Linux-64 s2s-linux-x64.zip       内置命令  PS: 在命令行模式下按下tab键会有命令补全提示！\n   命令 使用方法     databases 显示所有数据库名   use 指定使用哪个数据库   tables 显示当前数据库所有表   gen 生成指定的表，gen 表名   info 显示数据库所有信息   exit 退出命令行模式   clear 清理屏幕内容    使用案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146  $:\u0026gt; s2s java ______ .-----.|__ |.-----. |__ --|| __||__ --| |_____||______||_____| 🥳: You have entered the command line mode! 🥳: Press the \u0026#39;tab\u0026#39; key to get a prompt！ 🥳: Enter `exit` to exit the program! 😃:s2s\u0026gt;databases +---+--------------------+ | * | Database | +---+--------------------+ | 1 | information_schema | | 2 | emp_db | | 3 | mysql | | 4 | performance_schema | | 5 | sys | | 6 | test_db | +---+--------------------+ 😃:s2s\u0026gt;use emp_db 🤖‍: Selected as database 👉 `emp_db`！ 😃:s2s\u0026gt;tables +---+-----------+ | * | Tables | +---+-----------+ | 1 | user_info | +---+-----------+ 😃:s2s\u0026gt;gen user_info package model import java.sql.Timestamp; import java.math.BigDecimal; import java.math.BigInteger; public class UserInfo { // 用户账号  private String Account; // 用户创建时间  private Timestamp CreateTime; // 用户更新时间  private Timestamp UpdatedDate; // 用户年龄  private short Age; // 用户余额  private BigDecimal Money; // 用户ID  private BigInteger Uid; public String getAccount() { return Account; } public void setAccount(String Account) { this.Account = Account; } public Timestamp getCreateTime() { return CreateTime; } public void setCreateTime(Timestamp CreateTime) { this.CreateTime = CreateTime; } public Timestamp getUpdatedDate() { return UpdatedDate; } public void setUpdatedDate(Timestamp UpdatedDate) { this.UpdatedDate = UpdatedDate; } public short getAge() { return Age; } public void setAge(short Age) { this.Age = Age; } public BigDecimal getMoney() { return Money; } public void setMoney(BigDecimal Money) { this.Money = Money; } public BigInteger getUid() { return Uid; } public void setUid(BigInteger Uid) { this.Uid = Uid; } @Override public String toString() { return \u0026#34;user_info{\u0026#34; + \u0026#34;Account=\u0026#34; + Account + \u0026#34;,\u0026#34;+ \u0026#34;CreateTime=\u0026#34; + CreateTime + \u0026#34;,\u0026#34;+ \u0026#34;UpdatedData=\u0026#34; + UpdatedDate + \u0026#34;,\u0026#34;+ \u0026#34;Age=\u0026#34; + Age + \u0026#34;,\u0026#34;+ \u0026#34;Money=\u0026#34; + Money + \u0026#34;,\u0026#34;+ \u0026#34;Uid=\u0026#34; + Uid + \u0026#34;,\u0026#34;+ \u0026#34;}\u0026#34;; } } 😃:s2s\u0026gt;exit 🤖‍: Bye👋 :)      导入包  本库支持你二次开发使用，你只需要导入本包即可在你的代码中进行扩充开发，但是目前仅支持go语言！\n 下载  1  go get -u github.com/higker/s2s   导入并且使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \u0026#34;github.com/higker/s2s/core/lang/java\u0026#34; \u0026#34;github.com/higker/s2s/core/db\u0026#34; ) func main() { // 创建一个Java的代码生成器  structure := java.New() // 数据库连接信息  if err := structure.OpenDB( \u0026amp;db.Info{ HostIPAndPort: os.Getenv(\u0026#34;s2s_host\u0026#34;), // 数据库IP  UserName: os.Getenv(\u0026#34;s2s_user\u0026#34;), // 数据库用户名  Password: os.Getenv(\u0026#34;s2s_pwd\u0026#34;), // 数据库密码  Type: db.MySQL, // 数据库类型 PostgreSQL Oracle  Charset: os.Getenv(\u0026#34;s2s_charset\u0026#34;), }, ); err != nil { // Failed to establish a connection to the database!  // .... logic code  } defer structure.Close() structure.SetSchema(\u0026#34;选择数据库名\u0026#34;) // 实现了io.Writer即可  structure.Parse(os.Stdout,\u0026#34;表名\u0026#34;) }      其他  目前仅支持mysql数据库，如果有想贡献代码提issues！跟多需求： 1. 支持linux管道命令这样就可以可编程操作了，前面一个输出就是后面一个程序的输入。\n 可以帮忙点一个star✨谢谢！！！ https://github.com/auula/s2s  ","date":"Sep 16","permalink":"http://blog.ibyte.me/post/golang-database-reverse-engineering/","tags":null,"title":"Golang Database Reverse Engineering"},{"categories":null,"contents":"   lifetime寿命  Rust中的每一个引用都有一个有效的作用域，生命周期就是为这个作用域服务的，大部分生命周期编译器可以推断出来，可以是隐式的。但是如果在某些情况下编译器就无法正常推断出来了，需要我们自己手动标注，标注生命周期语法就是'a这样的语法。\n   为什么需要生命周期？  例如下面例子就是在两个字符串切片里面查找最长的那个并且返回！\n1 2 3 4 5 6 7 8  // \u0026#39;a 是指3个引用的作用域生命周期要一致 fn find_long_str\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;astr,y: \u0026amp;\u0026#39;astr)-\u0026gt; \u0026amp;\u0026#39;astr{ifx.len()\u0026gt;y.len(){x}else{y}}  上面我就加注了生命周期标识符，如果不加编译器会报错，原因是因为我们这个函数引用的是外部的变量，不能确定引用的变量是否已经被销毁了，那这样就是悬垂引用！\n1 2 3 4 5 6 7 8 9 10  letstr1=String::from(\u0026#34;Hello\u0026#34;);letstr2;letresult;{//let str2 = String::from(\u0026#34; World!\u0026#34;); str2=String::from(\u0026#34; World!\u0026#34;);result=find_long_str(str1.as_str(),\u0026amp;str2);}// 这里借用检测就提示 引用了已经销毁的资源了 println!(\u0026#34;{}\u0026#34;,result);  加了生命周期标识符之后，如果我把let str2 = String::from(\u0026quot; World!\u0026quot;);取消注释放在一个内部作用域里面定义，那么这时调用 find_long_str编译器就会报错，因为我在下面出了作用域还使用了find_long_str返回的结果，而这个结果可能就是str2的内容， 使用这个是违反了所有权规则的，str2离开内部作用域就被销毁了。\n在标注生命周期fn find_long_str\u0026lt;'a\u0026gt;(x: \u0026amp;'a str, y: \u0026amp;'a str) -\u0026gt; \u0026amp;'a str之后编译器就知道输入参数和返回参数生命周期是要一致的，并且返回值生命周期肯定是取生命周期最短的那个的。\n   总结   生命周期是确保被引用的值是有效的。 引用的生命周期肯定是小于或者等于资源所有者的。 如果是在函数里面创建的资源，应该是直接返回其所有权，而不是引用。 每个生命周期标注都有不同的生命周期，如果有输入的生命周期，那么输出的生命周期也是一致的。 self的生命周期会被赋给输出的生命周期。     其他   当然上面是我刚刚入坑总结话，有错误地方望大佬指教！ https://play.rust-lang.org/?version=stable\u0026amp;mode=debug\u0026amp;edition=2018\u0026amp;gist=a868aa030fa934b22cd770727f42724d  ","date":"Sep 16","permalink":"http://blog.ibyte.me/post/rust-lifetime/","tags":null,"title":"Rust Lifetime"},{"categories":null,"contents":"   什么是智能指针？  在Rust中智能指针有很多种，用大白话说就是一个数据结构，实现了一些特殊的trait从而达到某种特性和功能，然后去管理某块内存上的数据，相当于一个盒子一样包装一层，这篇文章将介绍一下Box。\n   Deref  Deref这个trait只要实现了它那么你自定义的结构体，就可以使用*解引用拿取你结构体里面所包装的数据，熟悉Rust都知道*是用来解引用的，下面的I32Box(i32)就是实现了Deref从而达到直接使用*拿取出内部的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  usestd::ops::Deref;struct I32Box(i32);// impl Deref implDerefforI32Box{type Target=i32;fn deref(\u0026amp;self)-\u0026gt; \u0026amp;Self::Target{\u0026amp;self.0}}implI32Box{fn new(v:i32)-\u0026gt; Self{I32Box(v)}}fn main(){letn=I32Box::new(1024_i32);println!(\u0026#34;{}\u0026#34;,*n);}     Drop  Rust里面有drop函数，也有一个Drop的trait同样如果自定义的结构体实现这个Drop，那么就你变量离开作用域的时候执行自定义Drop的方法的逻辑。\n1 2 3 4 5  implDropforI32Box{fn drop(\u0026amp;mutself){println!(\u0026#34;啊，挂了，I32Box({:?})被清理了！\u0026#34;,self.0)}}  例如为I32Box实现Drop的drop函数，运行：\n1 2 3 4 5 6 7  Compiling playground v0.0.1 (/playground) Finished dev [unoptimized + debuginfo] target(s) in 1.33s Running `target/debug/playground` 1024 啊，挂了，I32Box(1024)被清理了！   当I32Box离开自己的作用域那么它会自动执行drop方法。\n   Box  有了这些特殊的trait基础之后，智能指针就自身有了这种行为了，就能管理内部的数据了。\nBox智能指针它管理的数据，内存是分配在heap上的，可以在堆上存储我们自定义的的数据，而把指针放在栈上。有这些特性，我们就可以使用Box实现一个类似动态数组的数据结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #[derive(Debug)]struct DynamicArr{cap:i32,len:i32,data:Box\u0026lt;[i32]\u0026gt;,}implDynamicArr{fn new()-\u0026gt; DynamicArr{DynamicArr{cap:10,len:0,data: Box::new([0;10]),}}fn push(\u0026amp;mutself,v:i32){// expansion ifself.len==self.cap{// add 10 capacity letmutnew_arr=Box::new([0;20]);letmutindex=0;forvinself.data.iter(){new_arr[index]=*v;index+=1;}self.data=new_arr;self.cap+=indexasi32;}self.data[self.lenasusize]=v;self.len+=1;}}fn main(){letmutarr=DynamicArr::new();forvin0..16{arr.push(v);}println!(\u0026#34;{:#?}\u0026#34;,arr)}  例如上面通过Box智能指针实现一个自定义DynamicArr结构，它在我们添加数组的时候会检查容量，当达到阈值就会发生expansion，上面只是个小demo，还有bug，只是为了演示Box智能指针的使用。\n   其他   I32Box DynamicArr  ","date":"Sep 16","permalink":"http://blog.ibyte.me/post/rust-box-pointer/","tags":null,"title":"Rust Box Pointer"},{"categories":null,"contents":"   前 言   在开发高并发系统时，我们可能会遇到接口访问频次过高，为了保证系统的高可用和稳定性，这时候就需要做流量限制，你可能是用的 Nginx 这种 Web Server 来控制请求，也可能是用了一些流行的类库实现。限流是高并发系统的一大杀器，在设计限流算法之前我们先来了解一下它们是什么。\n    限 流  限流的目的是通过对并发访问请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。通过对并发（或者一定时间窗口内）请求进行限速来保护系统，一旦达到限制速率则拒绝服务（定向到错误页或告知资源没有了）、排队等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据）。\n如 图:\n如图上的漫画，在某个时间段流量上来了，服务的接口访问频率可能会非常快，如果我们没有对接口访问频次做限制可能会导致服务器无法承受过高的压力挂掉，这时候也可能会产生数据丢失，所以就要对其进行限流处理。\n限流算法就可以帮助我们去控制每个接口或程序的函数被调用频率，它有点儿像保险丝，防止系统因为超过访问频率或并发量而引起瘫痪。我们可能在调用某些第三方的接口的时候会看到类似这样的响应头：\n1 2 3  X-RateLimit-Limit:60//每秒60次请求X-RateLimit-Remaining:22//当前还剩下多少次X-RateLimit-Reset:1612184024//限制重置时间  上面的 HTTP Response 是通过响应头告诉调用方服务端的限流频次是怎样的，保证后端的接口访问上限。为了解决限流问题出现了很多的算法，它们都有不同的用途，通常的策略就是拒绝超出的请求，或者让超出的请求排队等待。\n一般来说，限流的常用处理手段有：\n 计数器 滑动窗口 漏桶 令牌桶     计数器   计数器是一种最简单限流算法，其原理就是：在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。 这个就像你去坐车一样，车厢规定了多少个位置，满了就不让上车了，不然就是超载了，被交警叔叔抓到了就要罚款的，如果我们的系统那就不是罚款的事情了，可能直接崩掉了。\n  可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。 当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。 如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。 如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。  代码实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  package main import ( \u0026#34;log\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Counter struct { rate int //计数周期内最多允许的请求数  begin time.Time //计数开始时间  cycle time.Duration //计数周期  count int //计数周期内累计收到的请求数  lock sync.Mutex } func (l *Counter) Allow() bool { l.lock.Lock() defer l.lock.Unlock() if l.count == l.rate-1 { now := time.Now() if now.Sub(l.begin) \u0026gt;= l.cycle { //速度允许范围内， 重置计数器  l.Reset(now) return true } else { return false } } else { //没有达到速率限制，计数加1  l.count++ return true } } func (l *Counter) Set(r int, cycle time.Duration) { l.rate = r l.begin = time.Now() l.cycle = cycle l.count = 0 } func (l *Counter) Reset(t time.Time) { l.begin = t l.count = 0 } func main() { var wg sync.WaitGroup var lr Counter lr.Set(3, time.Second) // 1s内最多请求3次  for i := 0; i \u0026lt; 10; i++ { wg.Add(1) log.Println(\u0026#34;创建请求:\u0026#34;, i) go func(i int) { if lr.Allow() { log.Println(\u0026#34;响应请求:\u0026#34;, i) } wg.Done() }(i) time.Sleep(200 * time.Millisecond) } wg.Wait() }   OutPut:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  2021/02/01 21:16:12 创建请求: 0 2021/02/01 21:16:12 响应请求: 0 2021/02/01 21:16:12 创建请求: 1 2021/02/01 21:16:12 响应请求: 1 2021/02/01 21:16:12 创建请求: 2 2021/02/01 21:16:13 创建请求: 3 2021/02/01 21:16:13 创建请求: 4 2021/02/01 21:16:13 创建请求: 5 2021/02/01 21:16:13 响应请求: 5 2021/02/01 21:16:13 创建请求: 6 2021/02/01 21:16:13 响应请求: 6 2021/02/01 21:16:13 创建请求: 7 2021/02/01 21:16:13 响应请求: 7 2021/02/01 21:16:14 创建请求: 8 2021/02/01 21:16:14 创建请求: 9   可以看到我们设置的是每200ms创建一个请求，明显高于1秒最多3个请求的限制，运行起来之后发现编号为 2、3、4、8、9 的请求被丢弃，说明限流成功。\n那么问题来了，如果有个需求对于某个接口 /query 每分钟最多允许访问 200 次，假设有个用户在第 59 秒的最后几毫秒瞬间发送 200 个请求，当 59 秒结束后 Counter 清零了，他在下一秒的时候又发送 200 个请求。那么在 1 秒钟内这个用户发送了 2 倍的请求，这个是符合我们的设计逻辑的，这也是计数器方法的设计缺陷，系统可能会承受恶意用户的大量请求，甚至击穿系统。\n如下图:\n这种方法虽然简单，但也有个大问题就是没有很好的处理单位时间的边界。\n   滑动窗口  滑动窗口是针对计数器存在的临界点缺陷，所谓 滑动窗口（Sliding window） 是一种流量控制技术，这个词出现在 TCP 协议中。滑动窗口把固定时间片进行划分，并且随着时间的流逝，进行移动，固定数量的可以移动的格子，进行计数并判断阀值。\n如 图：\n上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。\n那么滑动窗口如何解决我们上面遇到的问题呢？来看下面的图：\n当用户在0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。\n其实计数器就是滑动窗口啊，只不过只有一个格子而已，所以想让限流做的更精确只需要划分更多的格子就可以了，为了更精确我们也不知道到底该设置多少个格子，格子的数量影响着滑动窗口算法的精度，依然有时间片的概念，无法根本解决临界点问题。\n 相关算法实现 github.com/RussellLuo/slidingwindow     漏 桶  漏桶算法（Leaky Bucket），原理就是一个固定容量的漏桶，按照固定速率流出水滴。用过水龙头都知道，打开龙头开关水就会流下滴到水桶里，而漏桶指的是水桶下面有个漏洞可以出水。如果水龙头开的特别大那么水流速就会过大，这样就可能导致水桶的水满了然后溢出。\n如 图：\n一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率（处理速度），从而达到 流量整形 和 流量控制 的效果。\n代码实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  type LeakyBucket struct { rate float64 //固定每秒出水速率  capacity float64 //桶的容量  water float64 //桶中当前水量  lastLeakMs int64 //桶上次漏水时间戳 ms  lock sync.Mutex } func (l *LeakyBucket) Allow() bool { l.lock.Lock() defer l.lock.Unlock() now := time.Now().UnixNano() / 1e6 eclipse := float64((now - l.lastLeakMs)) * l.rate / 1000 //先执行漏水  l.water = l.water - eclipse //计算剩余水量  l.water = math.Max(0, l.water) //桶干了  l.lastLeakMs = now if (l.water + 1) \u0026lt; l.capacity { // 尝试加水,并且水还未满  l.water++ return true } else { // 水满，拒绝加水  return false } } func (l *LeakyBucket) Set(r, c float64) { l.rate = r l.capacity = c l.water = 0 l.lastLeakMs = time.Now().UnixNano() / 1e6 }   漏桶算法有以下特点：\n 漏桶具有固定容量，出水速率是固定常量（流出请求） 如果桶是空的，则不需流出水滴 可以以任意速率流入水滴到漏桶（流入请求） 如果流入水滴超出了桶的容量，则流入的水滴溢出（新请求被拒绝）  漏桶限制的是常量流出速率（即流出速率是一个固定常量值），所以最大的速率就是出水的速率，不能出现突发流量。\n   令牌桶算法  令牌桶算法（Token Bucket）是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。\n我们有一个固定的桶，桶里存放着令牌（token）。一开始桶是空的，系统按固定的时间（rate）往桶里添加令牌，直到桶里的令牌数满，多余的请求会被丢弃。当请求来的时候，从桶里移除一个令牌，如果桶是空的则拒绝请求或者阻塞。\n实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  type TokenBucket struct { rate int64 //固定的token放入速率, r/s  capacity int64 //桶的容量  tokens int64 //桶中当前token数量  lastTokenSec int64 //桶上次放token的时间戳 s  lock sync.Mutex } func (l *TokenBucket) Allow() bool { l.lock.Lock() defer l.lock.Unlock() now := time.Now().Unix() l.tokens = l.tokens + (now-l.lastTokenSec)*l.rate // 先添加令牌  if l.tokens \u0026gt; l.capacity { l.tokens = l.capacity } l.lastTokenSec = now if l.tokens \u0026gt; 0 { // 还有令牌，领取令牌  l.tokens-- return true } else { // 没有令牌,则拒绝  return false } } func (l *TokenBucket) Set(r, c int64) { l.rate = r l.capacity = c l.tokens = 0 l.lastTokenSec = time.Now().Unix() }   令牌桶有以下特点：\n 令牌按固定的速率被放入令牌桶中 桶中最多存放 B 个令牌，当桶满时，新添加的令牌被丢弃或拒绝 如果桶中的令牌不足 N 个，则不会删除令牌，且请求将被限流（丢弃或阻塞等待）  令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌\u0026hellip;），并允许一定程度突发流量。\n   小 结  目前常用的是令牌桶这种，本文介绍了几种常见的限流算法实现，文章撰写不易，点个关注不迷路。\n","date":"Sep 16","permalink":"http://blog.ibyte.me/post/traffic-restrictions/","tags":null,"title":"Traffic Restrictions"},{"categories":null,"contents":"   概 述  随着互联网的高速发展，信息安全问题已经成为企业最为关注的焦点之一，而前端又是引发企业安全问题的高危据点。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持、非法调用 API 等新型安全问题。当然，浏览器自身也在不断在进化和发展，不断引入 CSP、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要我们技术人员不断对系统进行“查漏补缺”。\n   废话少说，先看问题  为了模拟问题我这边用go写了2个服务端的代码，正常交易系统的API，当然这里只是为了演示漏洞利用，代码比较简单如下:\ntransaction.go 内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cast\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) // 模拟数据存储 type user struct { id string money int } var userdata []*user func init() { userdata = append(userdata, \u0026amp;user{id: \u0026#34;Tom\u0026#34;, money: 10000}) userdata = append(userdata, \u0026amp;user{id: \u0026#34;John\u0026#34;, money: 10000}) userdata = append(userdata, \u0026amp;user{id: \u0026#34;hack\u0026#34;, money: 0}) } // 模拟交易系统API func main() { http.HandleFunc(\u0026#34;/transaction\u0026#34;, transactionHandler) http.ListenAndServe(\u0026#34;:1999\u0026#34;, nil) } // 假设这是交易处理器 func transactionHandler(w http.ResponseWriter, req *http.Request) { if req.URL.Path != \u0026#34;/transaction\u0026#34; { http.Error(w, \u0026#34;404 not found.\u0026#34;, http.StatusNotFound) return } switch req.Method { case \u0026#34;GET\u0026#34;: http.ServeFile(w, req, \u0026#34;form.html\u0026#34;) case \u0026#34;POST\u0026#34;: if err := req.ParseForm(); err != nil { fmt.Fprintf(w, \u0026#34;ParseForm() err: %v\u0026#34;, err) return } if e := transaction(req.FormValue(\u0026#34;Id\u0026#34;), req.FormValue(\u0026#34;toId\u0026#34;), req.FormValue(\u0026#34;money\u0026#34;)); e != nil { fmt.Fprintf(w,\u0026#34;%s\u0026#34;,e.Error()) return } fmt.Fprintf(w,\u0026#34;transaction successful.\u0026#34;) default: fmt.Fprintf(w, \u0026#34;Sorry, only GET and POST methods are supported.\u0026#34;) } } func transaction(Id, toId, money string) error { if len(Id) \u0026lt;= 0 || len(toId) \u0026lt;= 0 || cast.ToInt(money) \u0026lt;= 0 { return errors.New(\u0026#34;form invalid parameter\u0026#34;) } var user, recipient *user for _, u := range userdata { if u.id == Id { user = u break } } for _, r := range userdata { if r.id == toId { recipient = r break } } // 用户不存在 \tif user == nil || recipient == nil { return errors.New(\u0026#34;user does not exist\u0026#34;) } // 有钱才能转账 \tif user.money \u0026lt; 0 || user.money \u0026lt; cast.ToInt(money) { return errors.New(\u0026#34;your balance is insufficient\u0026#34;) } user.money = user.money - cast.ToInt(money) recipient.money = recipient.money + cast.ToInt(money) log.Printf(\u0026#34;用户 %s 向用户 %s 转账 %s 元.\u0026#34;, Id, toId, money) return nil }   我们把上面的代码跑起来，go run transaction.go\n[Running] go run \u0026quot;/Users/ding/Desktop/CSRF_Demo/transaction.go\u0026quot; 2021/03/12 21:50:08 Transaction Server Running.... 好了，服务器正常跑起来了，按照我们正常的系统流程是，我们登陆到了系统里面，系统里面有我们的浏览器会话数据，这时我们只想通过系统给出的交易接口操作就可以了，这里为了方便演示我使用postman进行测试。\n可以看到我们的交易系统设计的所需的参数，并且我们填写了请求表单数据，并且提交了这个请求。我们去服务器看看日志:\n[Running] go run \u0026quot;/Users/ding/Desktop/CSRF_Demo/transaction.go\u0026quot; 2021/03/12 21:50:08 Transaction Server Running.... 2021/03/12 21:54:41 用户 Tom 向用户 John 转账 2000 元. 可以看到有一条转账记录，说明我们操作成功了。\n   开始漏洞利用  按照正常人的思维我们就正常操作就行了，但是世界这么大怎么可能没有坏人呢？？？那下面把第一个服务器跑起来，并且访问第二个服务器看看结果怎么样？？\ncsrf.go文件里面内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main(){ http.HandleFunc(\u0026#34;/csrf\u0026#34;,csrfHandler) log.Println(\u0026#34;CSRF Server Running....\u0026#34;) http.ListenAndServe(\u0026#34;:2021\u0026#34;, nil) } func csrfHandler(writer http.ResponseWriter, request *http.Request) { http.ServeFile(writer, request, \u0026#34;csrf.html\u0026#34;) }   首先我把攻击利用服务器启动 go run csrf.go\n1  2021/03/12 22:16:43 CSRF Server Running....   然后我在同一浏览器里面访问这个地址http://127.0.0.1:2021/csrf。\n在你回车的那一秒，其实这个漏洞已经利用成功了。这个过程可能不是你直接在浏览器地址框直接输入，也可能是你在打开其他网站，其他网站里面有一个地址就是这个地址，或者是你在QQ或者一些聊天软件上，别人给你发送一个地址，在你点击那一秒这个攻击就成功了。\n那怎么证明成功了呢？我们去看看转账系统的日志。。\n可以看到有一条转账日志记录，这就是我们刚刚通过漏洞利用达成的转账效果。\n   那这个是怎么做到的呢？  通过我们攻击利用服务器上的代码可以看出来我们在服务器返回了一个csrf.html文件，那这个文件做了什么？？？\n文件内容如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;csrf 攻击演示\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;http://127.0.0.01:1999/transaction\u0026#34; method=POST\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;Id\u0026#34; value=\u0026#34;Tom\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;money\u0026#34; value=\u0026#34;5000\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;toId\u0026#34; value=\u0026#34;hack\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; document.forms[0].submit(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   相信是个程序员都能看懂我做了什么吧，不用细说。\n   CSRF攻击和防范  上面攻击过程就是我们常说的CSRF攻击，相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”，真的是这样吗？\nCSRF攻击的例子已经不是单个个例了，Gmail，Facebook，Twitter，YouTube这些都有个类似的漏洞事件。\n https://www.davidairey.com/google-gmail-security-hijack/   CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n 我刚才的例子就是一个典型的CSRF例子，受害者登录a.com，并保留了登录凭证（Cookie），攻击者引诱受害者访问了b.com，b.com 向 a.com 发送了一个请求：a.com/xx。浏览器会默认携带a.com的Cookie，a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求，从而达到黑客的目的。\n   小 结  涉及到铭感数据操作的加强验证，客户端的数据不可信，服务器加强对数据校验，和加一些风控策略，例如验证码，手机短信，jwt，或者第三方验证码防火墙，也可以在请求的之前先拿到一个唯一的token，同源检测（Origin 和 Referer 验证），当然这些方法还不安全，如果有空会续更。\n","date":"Sep 16","permalink":"http://blog.ibyte.me/post/web-safe-csrf/","tags":null,"title":"Web Safe Csrf"},{"categories":null,"contents":"   概 述  大家都知道 session 是web应用在服务器端实现的一种用户和服务器之间认证的解决方案，目前 Go 标准包没有为 session 提供任何支持，本文我将讲解session的实现原理，和一些常见基于session安全产生的防御问题。\n当然有人可能看了会抬杠，说现在大部分不是前后端分离架构吗？对，你可以使用JWT解决你的问题。但是也有一些一体化web应用需要session，所以我准备造个轮子。自己造的轮子哪里出问题了，比别人更熟悉，有bug了，还不用求着别人修bug,自己修就好了，呵呵哈哈哈，当然这几句话有点皮😜。\n   需 求  我觉得一名好的程序员，在写程序之前应该列一下需求分析，整理一下思路，然后再去写代码。\n 支持内存存储会话数据 支持分布式redis会话存储 会话如果有心跳就自动续命30分钟（生命周期） 提供防御：中间人，会话劫持，会话重放等攻击     工作原理  首先必须了解工作原理才能写代码，这里我就稍微说一下，session是基于cookie实现的，一个session对应一个uuid也是sessionid，在服务器创建一个相关的数据结构，然后把这个sessionid通过cookie让浏览器保存着，下次浏览器请求过来了就会有sessionid，然后通过sessionid获取这个会话的数据。\n   代码实现  都是说着容易，实际写起来就是各种坑，不过我还是实现了。\n少说废话，还是直接干代码吧。\n 依赖关系  上面是设计的相关依赖关系图，session是一个独立的结构体， GlobalManager是整体的会话管理器负责数据持久化，过期会话垃圾回收工作♻️，storage是存储器接口，因为我们要实现两种方式存储会话数据或者以后要增加其他持久化存储，所以必须需要接口抽象支持，memory和redis是存储的具体实现。\nstorage接口  1 2 3 4 5 6 7 8 9  package sessionx // session storage interface type storage interface { Read(s *Session) error Create(s *Session) error Update(s *Session) error Remove(s *Session) error }   storage就9行代码，是具体的会话数据操作动作的抽象，全部参数使用的是session这个结构的指针，如果处理异常了就即错即返回。\n为什么把函数签名的形参使用指针类型的，这个我想看的懂人应该知道这是为什么了😁\nmemoryStore结构体  1 2 3  type memoryStore struct { sync.Map }   memoryStore结构体里面就嵌入sync.Map结构体，一开始是使用的map这种，但是后面发现在并发读写然后加sync.Mutex锁🔐，性能还不如直接使用sync.Map速度快。sync.Map用来做K:V存储的，也就是sessionid对应session data的。\n实现storage具体方法如下:\n1 2 3 4 5 6 7 8 9  func (m *memoryStore) Read(s *Session) error { if ele, ok := m.Load(s.ID); ok { // bug 这个不能直接 s = ele  s.Data = ele.(*Session).Data return nil } // s = nil  return fmt.Errorf(\u0026#34;id `%s` not exist session data\u0026#34;, s.ID) }   读取数据的时候先将持久化的数据读出来然后赋值给本次会话的session。\n注意: 在go的map中的struct中的字段不能够直接寻址，官方issue https://github.com/golang/go/issues/3117\n其他几个函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func (m *memoryStore) Create(s *Session) error { m.Store(s.ID, s) return nil } func (m *memoryStore) Remove(s *Session) error { m.Delete(s.ID) return nil } func (m *memoryStore) Update(s *Session) error { if ele, ok := m.Load(s.ID); ok { // 为什么是交换data 因为我们不确定上层是否扩容换了地址  ele.(*Session).Data = s.Data ele.(*Session).Expires = s.Expires //m.sessions[s.ID] = ele  return nil } return fmt.Errorf(\u0026#34;id `%s` updated session fail\u0026#34;, s.ID) }   这句话代码没有什么好说的，写过go都能看得懂。\n垃圾回收:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func (m *memoryStore) gc() { // recycle your trash every 10 minutes  for { time.Sleep(time.Minute * 10) m.Range(func(key, value interface{}) bool { if time.Now().UnixNano() \u0026gt;= value.(*Session).Expires.UnixNano() { m.Delete(key) } return true }) runtime.GC() // log.Println(\u0026#34;gc running...\u0026#34;)  } }   比较会话过期时间，过期就删除会话，以上就是内存存储的实现。\nredisStore结构体  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  type redisStore struct { sync.Mutex sessions *redis.Client } func (rs *redisStore) Read(s *Session) error { sid := fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, mgr.cfg.RedisKeyPrefix, s.ID) bytes, err := rs.sessions.Get(ctx, sid).Bytes() if err != nil { return err } if err := rs.sessions.Expire(ctx, sid, mgr.cfg.TimeOut).Err(); err != nil { return err } if err := decoder(bytes, s); err != nil { return err } // log.Println(\u0026#34;redis read:\u0026#34;, s)  return nil } func (rs *redisStore) Create(s *Session) error { return rs.setValue(s) } func (rs *redisStore) Update(s *Session) error { return rs.setValue(s) } func (rs *redisStore) Remove(s *Session) error { return rs.sessions.Del(ctx, fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, mgr.cfg.RedisKeyPrefix, s.ID)).Err() } func (rs *redisStore) setValue(s *Session) error { bytes, err := encoder(s) if err != nil { return err } err = rs.sessions.Set(ctx, fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, mgr.cfg.RedisKeyPrefix, s.ID), bytes, mgr.cfg.TimeOut).Err() return err }   代码也就50行左右，很简单就是通过redis客户端对数据进行持久化操作，把本地的会话数据提供encoding/gob序列化成二进制写到redis服务器上存储，需要的时候再反序列化出来。\n那么问题来了，会有人问了，redis没有并发问题吗？\n👨‍💻‍： 那我肯定会回答，你在问这个问题之前我不知道你有没有了解过redis？？？\nRedis 并发竞争指的是多个 Redis 客户端同时 set key 引起的并发问题，Redis 是一种单线程机制的 NoSQL 数据库，所以 Redis 本身并没有锁的概念。\n但是多客户端同时并发写同一个 key，一个 key 的值是 1，本来按顺序修改为 2,3,4 ，最后 key 值是 4，但是因为并发去写 key，顺序可能就变成了 4,3,2，最后 key 值就变成了 2。\n我这个库当前也就一个客户端，如果你部署到多个机子，那就使用 setnx(key, value) 来实现分布式锁，我当前写的这个库没有提供分布式锁，具体请自行google。\nmanager结构体  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  type storeType uint8 const ( // memoryStore store type  M storeType = iota // redis store type  R SessionKey = \u0026#34;session-id\u0026#34; ) // manager for session manager type manager struct { cfg *Configs store storage } func New(t storeType, cfg *Configs) { switch t { case M: // init memory storage  m := new(memoryStore) go m.gc() mgr = \u0026amp;manager{cfg: cfg, store: m} case R: // parameter verify  validate := validator.New() if err := validate.Struct(cfg); err != nil { panic(err.Error()) } // init redis storage  r := new(redisStore) r.sessions = redis.NewClient(\u0026amp;redis.Options{ Addr: cfg.RedisAddr, Password: cfg.RedisPassword, // no password set  DB: cfg.RedisDB, // use default DB  PoolSize: int(cfg.PoolSize), // connection pool size  }) // test connection  timeout, cancelFunc := context.WithTimeout(context.Background(), 8*time.Second) defer cancelFunc() if err := r.sessions.Ping(timeout).Err(); err != nil { panic(err.Error()) } mgr = \u0026amp;manager{cfg: cfg, store: r} default: panic(\u0026#34;not implement store type\u0026#34;) } }   manager结构体也就两个字段，一个存放我们全局配置信息，一个我们实例化不同的持久化存储的存储器，其他代码就是辅助性的代码，不细说了。\nSession结构体  这个结构体是对应着浏览器会话的结构体，设计原则是一个id对应一个session结构体。\n1 2 3 4 5 6 7 8 9 10 11  type Session struct { // 会话ID  ID string // session超时时间  Expires time.Time // 存储数据的map  Data map[interface{}]interface{} _w http.ResponseWriter // 每个session对应一个cookie  Cookie *http.Cookie }   具体操作函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // Get Retrieves the stored element data from the session via the key func (s *Session) Get(key interface{}) (interface{}, error) { err := mgr.store.Read(s) if err != nil { return nil, err } s.refreshCookie() if ele, ok := s.Data[key]; ok { return ele, nil } return nil, fmt.Errorf(\u0026#34;key \u0026#39;%s\u0026#39; does not exist\u0026#34;, key) } // Set Stores information in the session func (s *Session) Set(key, v interface{}) error { lock[\u0026#34;W\u0026#34;](func() { if s.Data == nil { s.Data = make(map[interface{}]interface{}, 8) } s.Data[key] = v }) s.refreshCookie() return mgr.store.Update(s) } // Remove an element stored in the session func (s *Session) Remove(key interface{}) error { s.refreshCookie() lock[\u0026#34;R\u0026#34;](func() { delete(s.Data, key) }) return mgr.store.Update(s) } // Clean up all data for this session func (s *Session) Clean() error { s.refreshCookie() return mgr.store.Remove(s) } // 刷新cookie 会话只要有操作就重置会话生命周期 func (s *Session) refreshCookie() { s.Expires = time.Now().Add(mgr.cfg.TimeOut) s.Cookie.Expires = s.Expires // 这里不是使用指针  // 因为这里我们支持redis 如果web服务器重启了  // 那么session数据在内存里清空  // 从redis读取的\u0008数据反序列化地址和重新启动的不一样  // 所有直接数据拷贝  http.SetCookie(s._w, s.Cookie) }   上面是几个函数是，会话的数据操作函数，refreshCookie()是用来刷新浏览器cookie信息的，因为我在设计的时候只有浏览器有心跳也就是有操作数据的时候，管理器就默认为这个浏览器会话还是活着的，会自动同步更新cookie过期时间，这个更新过程可不是光刷新cookie就完事的了，持久化的话的数据过期时间也一样更新了。\nHandler方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // Handler Get session data from the Request func Handler(w http.ResponseWriter, req *http.Request) *Session { // 从请求里面取session  var session Session session._w = w cookie, err := req.Cookie(mgr.cfg.Cookie.Name) if err != nil || cookie == nil || len(cookie.Value) \u0026lt;= 0 { return createSession(w, cookie, \u0026amp;session) } // ID通过编码之后长度是73位  if len(cookie.Value) \u0026gt;= 73 { session.ID = cookie.Value if mgr.store.Read(\u0026amp;session) != nil { return createSession(w, cookie, \u0026amp;session) } // 防止web服务器重启之后redis会话数据还在  // 但是浏览器cookie没有更新  // 重新刷新cookie  // 存在指针一致问题，这样操作还是一块内存，所有我们需要复制副本  _ = session.copy(mgr.cfg.Cookie) session.Cookie.Value = session.ID session.Cookie.Expires = session.Expires http.SetCookie(w, session.Cookie) } // 地址一样不行！！！  // log.Printf(\u0026#34;mgr.cfg.Cookie pointer:%p \\n\u0026#34;, mgr.cfg.Cookie)  // log.Printf(\u0026#34;session.cookie pointer:%p \\n\u0026#34;, session.Cookie)  return \u0026amp;session } func createSession(w http.ResponseWriter, cookie *http.Cookie, session *Session) *Session { // init session parameter  session.ID = generateUUID() session.Expires = time.Now().Add(mgr.cfg.TimeOut) _ = mgr.store.Create(session) // 重置配置cookie模板  session.copy(mgr.cfg.Cookie) session.Cookie.Value = session.ID session.Cookie.Expires = session.Expires http.SetCookie(w, session.Cookie) return session }   Handler函数是从http请求里面读取到sessionid然后从持久化层读取数据然后实例化一个session结构体的函数，没有啥好说的，注释写上面了。\n   安全防御问题  首先我还是那句话：不懂攻击，怎么做防守。 那我们先说说这个问题怎么产生的:\n 中间人攻击（Man-in-the-MiddleAttack，简称MITM攻击）是一种间接的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为中间人。\n 这个过程，正常用户在通过浏览器访问我们编写的网站，但是这个时候有个hack通过arp欺骗，把路由器的流量劫持到他的电脑上，然后黑客通过一些特殊的软件抓包你的网络请求流量信息，在这个过程中如果你sessionid如果存放在cookie中，很有可能被黑客提取处理，如果你这个时候登录了网站，这是黑客就拿到你的登录凭证，然后在登录进行重放也就是使用你的sessionid，从而达到访问你账户相关的数据目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func (s *Session) MigrateSession() error { // 迁移到新内存 防止会话一致引发安全问题  // 这个问题的根源在 sessionid 不变，如果用户在未登录时拿到的是一个 sessionid，登录之后服务端给用户重新换一个 sessionid，就可以防止会话固定攻击了。  s.ID = generateUUID() newSession, err := deepcopy.Anything(s) if err != nil { return errors.New(\u0026#34;migrate session make a deep copy from src into dst failed\u0026#34;) } newSession.(*Session).ID = s.ID newSession.(*Session).Cookie.Value = s.ID newSession.(*Session).Expires = time.Now().Add(mgr.cfg.TimeOut) newSession.(*Session)._w = s._w newSession.(*Session).refreshCookie() // 新内存开始持久化  // log.Printf(\u0026#34;old session pointer:%p \\n\u0026#34;, s)  // log.Printf(\u0026#34;new session pointer:%p \\n\u0026#34;, newSession.(*Session))  //log.Println(\u0026#34;MigrateSession:\u0026#34;, newSession.(*Session))  return mgr.store.Create(newSession.(*Session)) }   如果大家写过Java语言，都应该使用过springboot这个框架，如果你看过源代码，那就知道这个框架里面的session安全策略有一个migrateSession选项，表示在登录成功之后，创建一个新的会话，然后讲旧的 session 中的信息复制到新的 session 中。\n我参照他的策略，也同样在我这个库里面实现了，在用户匿名访问的时候是一个 sessionid，当用户成功登录之后，又是另外一个 sessionid，这样就可以有效避免会话固定攻击。\n使用的时候也可以随时使用通过MigrateSession进行调用，这个函数一但被调用，原始数据和id全部被刷新了，内存地址也换了，可以看我的源代码。\n   使用演示  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; sessionx \u0026#34;github.com/higker/sesssionx\u0026#34; ) var ( // 配置信息  cfg = \u0026amp;sessionx.Configs{ TimeOut: time.Minute * 30, RedisAddr: \u0026#34;127.0.0.1:6379\u0026#34;, RedisDB: 0, RedisPassword: \u0026#34;redis.nosql\u0026#34;, RedisKeyPrefix: sessionx.SessionKey, PoolSize: 100, Cookie: \u0026amp;http.Cookie{ Name: sessionx.SessionKey, Path: \u0026#34;/\u0026#34;, Expires: time.Now().Add(time.Minute * 30), // TimeOut  Secure: false, HttpOnly: true, }, } ) func main() { // R表示redis存储 cfg是配置信息 \tsessionx.New(sessionx.R, cfg) http.HandleFunc(\u0026#34;/set\u0026#34;, func(writer http.ResponseWriter, request *http.Request) { session := sessionx.Handler(writer, request) session.Set(\u0026#34;K\u0026#34;, time.Now().Format(\u0026#34;2006 01-02 15:04:05\u0026#34;)) fmt.Fprintln(writer, \u0026#34;set time value succeed.\u0026#34;) }) http.HandleFunc(\u0026#34;/get\u0026#34;, func(writer http.ResponseWriter, request *http.Request) { session := sessionx.Handler(writer, request) v, err := session.Get(\u0026#34;K\u0026#34;) if err != nil { fmt.Fprintln(writer, err.Error()) return } fmt.Fprintln(writer, fmt.Sprintf(\u0026#34;The stored value is : %s\u0026#34;, v)) }) http.HandleFunc(\u0026#34;/migrate\u0026#34;, func(writer http.ResponseWriter, request *http.Request) { session := sessionx.Handler(writer, request) err := session.MigrateSession() if err != nil { log.Println(err) } fmt.Fprintln(writer, session) }) _ = http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) }      小 结  推荐还是使用JWT这种方式做鉴权，不过也有一体化web应用的session也不会被这么早淘汰，如果上面有问题，欢迎大佬们pr，还有部分代码没有列出，可以去仓库看看。\n   相关链接  代码仓库：https://github.com/auula/sessionx\n","date":"Sep 16","permalink":"http://blog.ibyte.me/post/golang-web-session-implement/","tags":null,"title":"Golang Web Session Implement"},{"categories":null,"contents":"   前 言  谈到分布式应用那必然离不开分布式锁🔐的问题，分布式锁在分布式应用中应用广泛，本文就讲讲基于redis实现的分布式锁的一些问题。\n   锁  可能各位coder接触最多的还是在多线程的环境下，为了保证一个代码块在同一时间只能由一个线程访问情况，例如下图：\n对于单进程的并发场景，可以使用编程语言及相应的类库提供的锁，如Java中的 synchronized 语法以及 ReentrantLock，Golang中的sync包下面的mutex，Rust中的async_std::sync::Mutex，避免并发问题，这实际上是本地锁的方式。\n   分布式锁  但是现在流行的分布式架构，在分布式环境下，如何保证不同节点的线程同步执行呢？或者共享资源怎么上锁呢？？？\n在将应用拆分为分布式应用之前的单机系统中，对一些并发场景读取公共资源时如扣库存，卖车票之类的需求可以简单的使用同步或者是加锁就可以实现，但是应用分布式了之后系统由以前的单进程多线程的程序变为了多进程多线程，这时使用以上的解决方案明显就不够了。\n一般业界有几种解决方:\n 基于 DB 的唯一索引 基于 Memcached的 add 命令 基于 Zookeeper 的临时有序节点 基于 Redis 的NX EX 基于Chubby粗粒度分布式锁服务     Redis的坑你填了几个？   如果在分布式场景中，实现不同客户端的线程对代码和资源的同步访问，保证在多线程下处理共享数据的安全性，就需要用到分布式锁技术，我就来写写基于Redis的一些坑😁。\n 在分布式时，在程序中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。\nRedis 锁主要利用 Redis 的 setnx 命令实现，\n 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败,KEY 是锁的唯一标识，一般按业务来决定命名。 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 伪代码实现 fn main(){letkey: \u0026amp;\u0026#39;staticstr=\u0026#34;sync_lock\u0026#34;;ifup_lock(key,1)==1{// 设置超时 expire(key,30)// .....业务逻辑 }}// 基于redis SETNX 和 EXPIRE 的实现，问题代码 fn up_lock(key: \u0026amp;\u0026#39;staticstr,num: i8)-\u0026gt; i8 {// ..... 上锁逻辑 return1;}fn expire(key: \u0026amp;\u0026#39;staticstr,num: i8){// ... 自定义超时 }  写完这么一看还没有什么问题，其实上面🕳坑大着呢！！！如果你是这么去实现的，那笔者恭喜你，你掉坑里了😜（PS:这里不是代码问题导致的，而是SETNX 和 EXPIRE 非原子性导致的）。\n  SETNX 和 EXPIRE 非原子性  如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。\n 锁误解除  如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程A实际释放的线程是 B 加的锁，从而导致锁混乱，然后导致实际逻辑代码混乱和乃至关键数据丢失。\n 超时解锁导致并发  如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行，那就没有分布式锁存在的意义了🤷‍。\n 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。   不可重入  当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的，如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。\n   小 结  Redis是个高性能的中间件，但是如果用在分布式锁上实现依然存在问题，我在一些网络文章看到很多人大部分都是用redis来解决分布式锁问题，希望这篇文章能帮助到你，记得点个关注！！\n","date":"Sep 16","permalink":"http://blog.ibyte.me/post/redis-distributed-lock/","tags":null,"title":"Redis Distributed Lock"},{"categories":null,"contents":"   👨‍💻‍：直奔话题 HotRing，少说废话。   去年阿里的Tair团队发表过一篇论文HotRing: A Hotspot-Aware In-Memory Key-Value Store，这篇论文里面讲述了阿里的最快的KV分布式存储引擎核心HotRing的技术与实现，我看了他们的数据显示其引擎吞吐性能可达600M ops/s，这个速度比传统的KVS系统2.58倍的性能提升，于是我就抱着好奇去看看了那篇论文然后就有这篇文章。\n    👨‍💻‍： 有问题就有故事？  一个新东西或者技术出现，那就说明老的那套方案技术存在某种缺陷或者满足不了某种的特殊需求了\u0026hellip;\u0026hellip;\n问题动机就是：某一时刻流量上来了，系统扛不住了\u0026hellip; 只要说到高并发，相信这个回答占大多数。HotRing的出现也是这个原因，真的是面向问题编程😜。。。挖槽，真的验证这句话了。。。\n这张图就是传统的kvs架构图，不管你中间的那一层用什么，在某些时刻，缓存系统迎来巨大的访问量（双11秒杀），可能存在访问倾斜(什么？你问我什么是访问倾斜，好吧你不适合编程。😜)，大多数访问集中在极少数数据上（例如微博热点事件）。\n对于集群级别的热点监测倍受重视，如一致性 Hash，某个节点上的数据被读写访问次数远远高出其他节点，对此类行为没有很好的监测到。\n还有单机热问题上没有优化，例如计算机内存的KV存储热点和查询速度没有优化。\n一个好的存储这些事情都是必须去做的，从上到下，从下到上，每层都在解决一部分问题，总和就是一个大的问题，如果你不能把问题拆成小问题，那你那个问题不一定能解决的好，例如CPU Cache、LevelDB的设计。\n   👨‍💻‍：HotRing 干了什么？？？  现有技术，内存 KVS 对时延要求是很高的，一个在并发中无锁的数据结构尤为重要，然后就是一个能让热点数据能自我跑到最容易访问的地方提高读取速度的。\n 热点是动态变化的，如何检测，如何转移?  这个问题是逃不开的，在HotRing的设计，论文中提到了一个概念就是有序环。\n它做了什么？看得懂上图就能看出来，他把传统的Map的底层的存储链表+数组结构换成了一个环形链结构，然后通过head自由的控制指向哪一个节点。\n传统的结构可能你的数据在最后一层或者数据非常多，程序只能通过head顺序查找，时间复杂度O(n)\n而环形的结构，避免多次遍历希望把热点数据放在冲突链前面，传统的则需要不断修改节点，需要不断移动节点，必须从头节点开始，到尾节点终止。移动头指针的情况下，会导致一些节点无法被访问。\n移动热点不方便，需要把中间节点移动到头节点去，移动链表中的节点很复杂且难以做到无锁并发，就上图这个操作就要3步。\n改成环链，Head可以指向任意节点，即从任意节点开始遍历，然后还能对数据进行排序。\n为什么有序???  这个就属于环链的特点了，没有终结点，如果查找值不存在，无法判断何时终结。改成有序的了，可以根据前后项的关系判断是否终结本次查询。\n 前驱节点 \u0026lt; 待查找节点 \u0026lt;后驱节点 miss 前驱节点 \u0026gt; 后驱节点 \u0026amp;\u0026amp; 待查找节点 \u0026lt; 后驱节点 miss 前驱节点 \u0026gt; 后驱节点 \u0026amp;\u0026amp; 待查找节点 \u0026gt; 前驱节点 miss 待查找节点 == 节点 K hit  排序的过程就是利用key排序可以解决这个问题，若目标key介于连续两个item的key之间，说明为read miss操作，即可终止返回。由于实际系统中，数据key的大小通常为10~100B，比较会带来巨大的开销。哈希结构利用tag来减少key的比较开销。\ntag是哈希值的一部分，每个key计算的哈希值，前k位用来哈希表的定位，后n-k位作为冲突链中进一步区分key的标志。为了减小排序开销，我们构建字典序：order = (tag, key)，先根据tag进行排序，tag相同再根据key进行排序。\n有了这些条件，HotRing就是可控的了。\n   🔥：热点数据跟踪  由于在不同的时间里，热点数据都是不停变化的，可能t1-t2这个时间段热的数据可能是在n1节点上，在t段数据后有发生了变化在n2节点上。\n热点识别转移有两种策略：\n  随机移动策略，效率高、效果可能差（不需要采样、计算，响应速度快），例如第R次访问如果是 Hot Access，保持不变，如果是 Cold Access，移动头指针指向冷数据，在热点集中时非常有效，头指针会趋向于指向热点数据，否则可能会频繁摇摆。\n  统计采样策略，效率低、效果可能更好，索引格式有特殊要求如下图：\n   针对RCU更新操作的采样优化 热点继承防止冷启动 采样分析策略如何选出最优位置  内存指针分配64bits，address 实际使用了48bits，采样所需的元数据结构上面的图所示，分别在头指针处设置Total Counter，记录该环的访问总次数，每个item设置Counter记录该item的访问次数。因为内存指针需要分配64bits，但实际系统地址索引只使用其中的48bits。我们使用剩余16bits设置标志位(例如Total Counter、Counter等)，保证不会增加额外的元数据开销。该策略的优势是，通过采样分析，可以计算选出最优的头指针位置，稳态时性能表现更优。\n数据采样\n我来解释一下公式，k= 有多少个节点，ni= 当前节点访问频率，N总的访问次数，mod计算出来的内存指针需要移动次数，然后就是概率*访问的成本，然后累加就知道访问得到热点数据的成本，最后就是t就是指针调整到的节点。\n为什么不是直接转移到 max(ni)?\n这个问题显然就是如果你直接调整到热节点位置，那么这个环路上不只是有一个热点数据节点，所有需要使用采用经过公式计算之后的。\n 写入密集型的热点：RCU Read读热点、Update写入密集型热点 Less Than 8Bytes -- CAS More Than 8Bytes -- RCU 如果头指针指向的节点被 Update，给前驱节点 Counter + 1     🔐：无锁并发访问  Tair的RCU无锁引擎是HotRing的设计基础，因为没有对环形链表结构修改，所以不存在并发问题，可以直接不加锁访问。\n但是在并发插入时数据丢失问题，解决办法就是使用了CompareAndSwap，保证同时只有一个线程能够修改成功。\n什么是CompareAndSwap? 通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换。如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行 使内存中的数据变为新值。\nUpdate 和 Insertion 并发引发的数据丢失，怎么看这个图，假设B为热点数据，程序每次找的B必须经过A，因为A在环路上是在B前面，那么访问B多少次A就是多少次，那么这个不是理想的，那就让hard指针指向A让B之间没有其他的值。\n在链A-\u0026gt;B-\u0026gt;D上，线程1进行插入C的操作，同时线程2进行RCU更新B的操作，尝试更新为B\u0026rsquo;。线程1修改B的指针指向C，完成插入。而线程2修改A的指针指向B'完成更新。两个线程并发修改不同的内存，均可成功返回。但是这时遍历整条链(A-\u0026gt;B'-\u0026gt;D)，将发现C无法被遍历到，导致正确性问题。当线程2更新B时，首先需要将B的Occupied标志位置位。线程1插入C需要修改B的指针(Next Item Address)，若发现Occupied标志位已置位，则需要重新遍历链表，尝试插入，通过使并发操作竞争修改同一内存地址，保证并发操作的正确性，利用相同原理保证了头指针移动操作，与CRUD操作的并发正确性，因此实现了HotRing的无锁并发访问。\n更多细节自己去看论文吧，上面部分总结。\n   论文资料   https://www.usenix.org/system/files/fast20-chen_jiqiang.pdf  ","date":"Sep 16","permalink":"http://blog.ibyte.me/post/alibaba-hot-ring/","tags":null,"title":"Alibaba Hot Ring Perceive"},{"categories":null,"contents":"   概 述   好久没有更新rust相关的内容了，更新一波Rust的内容，本篇讲介绍一下Rust中的复合数据类型。\n    Composite Type  复合数据类型是一种数据类型，它可以原始的基本数据类型和其它的复合类型所构成， 构成一个复合类型的动作，又称作组合。\n本文讲介绍一下在Rust中有tuple、array、struct、enum几个复合类型。\n   tuple  tuple即元组，元组类型是由多个不同类型的元素组成的复合类型，通过()小括号把元素组织在一起成一个新的数据类型。元组的长度在定义的时候就已经是固定的了，不能修改，如果指定了元素的数据类型，那么你的元素就要对号入座！！！否则编译器会教训你！\n例子：\n1 2 3 4 5 6 7 8 9 10 11  fn main(){// 指定数据类型 lettup_type:(i8,i32,bool)=(21,-1024,true);// 解构元素 let(one,two,three)=tup_type;// 二维的元组 lettup_2d:(f64,(i8,i32,bool))=(3.1415927,(one,two,three));println!(\u0026#34;tup_2d = {:?}\u0026#34;,tup_2d);// 索引 println!(\u0026#34;π = {:?}\u0026#34;,tup_2d.0);}  元组的访问方式有好几种，通过下标去访问，也可以使用解构赋值给新的变量去访问，但是不支持迭代器去访问。\n1 2 3  forvintup_2d.1.iter(){println!(\u0026#34;{}\u0026#34;,v)}  1 2 3 4 5 6 7 8 9 10 11 12 13  Compiling playground v0.0.1 (/playground) error[E0599]: no method named `iter` found for tuple `(i8, i32, bool)` in the current scope --\u0026gt; src/main.rs:10:23 | 10 | for v in tup_type.iter() { | ^^^^ method not found in `(i8, i32, bool)` error: aborting due to previous error For more information about this error, try `rustc --explain E0599`. error: could not compile `playground` To learn more, run the command again with --verbose.   元组的每个元素的类型可以不同，因此您无法对其进行迭代。元组甚至不能保证以与类型定义相同的顺序存储数据，因此即使您自己为它们实现Iterator，它们也不适合进行有效的迭代。\n但是如果元素是支持实现了Iterator就可以通过.iter()进行迭代访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  letmutarrays:[usize;5]=[0;5];foriin0..5{arrays[i]=i+1;}println!(\u0026#34;{:?}\u0026#34;,arrays);lettup_arr:(\u0026amp;str,[usize;5])=(\u0026#34;tup_arr\u0026#34;,arrays);println!(\u0026#34;{:?}\u0026#34;,tup_arr);forvintup_arr.1.iter(){println!(\u0026#34;{}\u0026#34;,v)}  例如上的元素是一个array，Rust中的数组和其他语言一样，一组类型相同的元素组成的复合类型，数组在底层存储是一块连续的内存空间。\n   array  Rust中的数组声明是[T;n]进行的，T是元素类型，n是这组元素有多少个坑位，创建的时候可以去掉类型和大小，程序会自动推断出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 数组 letarr:[f32;3]=[1.0,2.2,3.33];println!(\u0026#34;{:?}\u0026#34;,arr);// 类型自动推导 letarr_infer=[\u0026#34;Hello\u0026#34;,\u0026#34;,\u0026#34;,\u0026#34;World!\u0026#34;];letmutstr=String::new();// 迭代器 forvinarr_infer.iter(){str.push_str(v);}println!(\u0026#34;str = {}\u0026#34;,str);  点击查看元组代码案例\n   enum  枚举类型，如果你之前从事过Java相关的开发应该不陌生，在Rust里面也有枚举类型，枚举类型是一个自定义数据类型，通过enum关键字来声明，body里面可以包含多个自定义的枚举值，枚举可以用来限制某个值或者类型范围。\n1 2 3 4 5  #[derive(Debug)]enum Gender{Boy,Girl,}  上面就定义一了个类型名字为Gender的枚举，Boy和Girl是枚举可供使用的值，#[derive(Debug)]注释是让Gender自动实现Debug tarit后面文章将深入。\n   struct  结构体可以把一些自定义的数据类型通过已有的类型组装成一个新的自定义数据类型，通过struct关键字就可以创建一个结构体，结构体字段格式name:type，name是结构体字段名，type是字段的类型，默认是不可变的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  fn main(){// 枚举现在取值范围 #[derive(Debug)]enum Gender{Boy,Girl,}// 定义一个结构体 #[derive(Debug)]struct Programmer\u0026lt;\u0026#39;skill\u0026gt;{name: String,skill: [\u0026amp;\u0026#39;skillstr;3],sex: Gender,}// 创建一个实例 letengineer=Programmer{name: String::from(\u0026#34;Jaco Ding\u0026#34;),// String类型内容可变 skill: [\u0026#34;Java\u0026#34;,\u0026#34;Go\u0026#34;,\u0026#34;Rust\u0026#34;],// 一个长度为3的字符串面量类型的数组 sex:Gender::Boy,// 通过枚举限制参数类型 };println!(\u0026#34;engineer = {:?}\u0026#34;,engineer);}  有了自定义的类型了也就是struct就可以通过自定义的类型来处理一些特殊的需求了，例如下面的代码定义了一个元素类型为Programmer长度为2的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  letDoris=Programmer{name: String::from(\u0026#34;Doris\u0026#34;),skill: [\u0026#34;Vue\u0026#34;,\u0026#34;TypeScript\u0026#34;,\u0026#34;JavaScript\u0026#34;],sex:Gender::Girl,};letJaco=Programmer{name: String::from(\u0026#34;Jaco\u0026#34;),skill: [\u0026#34;Java\u0026#34;,\u0026#34;Go\u0026#34;,\u0026#34;Rust\u0026#34;],sex:Gender::Boy,};letemployees:[Programmer;2]=[Doris,Jaco];foreinemployees.iter(){println!(\u0026#34;{:?}\u0026#34;,e)}  结构体Programmer上的\u0026lt;'skill\u0026gt; 解决skill数组的生命周期问题undeclared lifetime，所有权问题，所有权是Rust语言核心的知识点，这些在后面文章中慢慢更新。\n   小结  Rust中的结构体还有两种特殊结构：元组结构体、单结构体，枚举也有带有参数的枚举。。。本文就学习总结了一下常见复合类型的使用，未深入。\n","date":"Sep 16","permalink":"http://blog.ibyte.me/post/compound-data-type-of-rust/","tags":null,"title":"Compound Data Type of Rust"},{"categories":null,"contents":"   前言   断断续续看了半个月的Rust书，学了点基础，不知道做什么好？？于是我想着用业余时间撸一个command line application的骨架。然后就有了https://github.com/auula/falsework这个项目，falsework可以帮助你快速构建一个命令行应用。这篇文章写写falsework的使用并在后部分介绍一下怎么实现的。\n 看了看这张图，那我估计还在坡道起步。。\n   导入依赖   https://crates.io/crates/falsework  在你的项目中添加依赖如下：\n1 2  [dependencies] falsework = \u0026#34;0.1.3\u0026#34;      快速构建  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  usestd::error::Error;usefalsework::{app,cmd};fn main(){// 通过falsework创建一个骨架 letmutapp=falsework::app::new();// 应用元数据信息 app.name(\u0026#34;calculator\u0026#34;).author(\u0026#34;Leon Ding \u0026lt;ding@ibyte.me\u0026gt;\u0026#34;).version(\u0026#34;0.0.1\u0026#34;).description(\u0026#34;A calculator that only supports addition.\u0026#34;);// 构建命令行项 letmutcommand=cmd::CommandItem{// run 命令所对应命令行逻辑代码 run: |ctx|-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynError\u0026gt;\u0026gt;{// 通过上下文获取flag绑定的数据 letx=ctx.value_of(\u0026#34;--x\u0026#34;).parse::\u0026lt;i32\u0026gt;().unwrap();lety=ctx.value_of(\u0026#34;--y\u0026#34;).parse::\u0026lt;i32\u0026gt;().unwrap();println!(\u0026#34;{} + {} = {}\u0026#34;,x,y,x+y);// 如果处理发生了错误则调用 cmd::err_msg 会优雅的退出 // Err(cmd::err_msg(\u0026#34;Application produce error！\u0026#34;)); Ok(())},// 命令帮助信息 long: \u0026#34;这是一个加法计算程序需要两个flag参数 --x --y\u0026#34;,// 命令介绍 short: \u0026#34;加法计算\u0026#34;,// 通过add激活命令 r#use: \u0026#34;add\u0026#34;,}.build();// 给add命令绑定flag command.bound_flag(\u0026#34;--x\u0026#34;,\u0026#34;加数\u0026#34;);command.bound_flag(\u0026#34;--y\u0026#34;,\u0026#34;被加数\u0026#34;);// 往app里面添加一个命令集 app.add_cmd(command);// 最后run 程序开始监听命令行输入 app.run();}  上面这个例子运行起来结果:\n1 2  $: ./calculator add --x=10 --y=10 10 + 10 = 20   到此为止你就快速构建一个命令行计算器了，你只需要写你核心逻辑，其他操作falsework帮助你完成。\n 例如如果我不记得了命令了，只记得一个单词或者字母，程序会帮助你修复：  1 2 3 4 5  $: ./calculator a You need this command ? add a : The corresponding command set was not found!   可以看到程序提示你有一个对应的add命令可以使用，如果不知道add有啥参数，在后面 加上--help即可获得帮助信息：  1 2 3 4 5 6 7 8 9 10 11  $: ./calculator add --help Help: 这是一个加法计算程序需要两个flag参数 --x --y Usage: calculator add [flags] Flags: --y, 被加数 --x, 加数   构建出来主程序预览：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $: ./calculator A calculator that only supports addition. calculator 0.0.1 Leon Ding \u0026lt;ding@ibyte.me\u0026gt; Usage: calculator [command] Available Commands: add\t加法计算 Flags: --help help for calculator Use \u0026#34;calculator [command] --help\u0026#34; for more information about a command.      其他操作  有多种构建方式，例如下面的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #[test]fn test_add_commands(){letmutapp=falsework::app::new();app.name(\u0026#34;calculator\u0026#34;).author(\u0026#34;Leon Ding \u0026lt;ding@ibyte.me\u0026gt;\u0026#34;).version(\u0026#34;0.0.2\u0026#34;).description(\u0026#34;A command line program built with Falsework.\u0026#34;);letcommand_list=vec![cmd::CommandItem{run: |_ctx|-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynError\u0026gt;\u0026gt;{// _ctx.args 获取命令行参数 println!(\u0026#34;call foo command.\u0026#34;);Ok(())},long: \u0026#34;这是一个测试命令，使用foo将调用foo命令。\u0026#34;,short: \u0026#34;foo命令\u0026#34;,r#use: \u0026#34;foo\u0026#34;,},cmd::CommandItem{run: |_ctx|-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynError\u0026gt;\u0026gt;{println!(\u0026#34;call bar command.\u0026#34;);Ok(())},long: \u0026#34;这是一个测试命令，使用bar将调用bar命令。\u0026#34;,short: \u0026#34;bar命令\u0026#34;,r#use: \u0026#34;bar\u0026#34;,},].iter().map(|c|c.build()).collect();app.commands(command_list);println!(\u0026#34;{:#?}\u0026#34;,app);}     Falsework的设计  整体来说也就是3大块，对应一个cli程序抽象的话也就这么多了，然后就是对单块的结构进行封装如图，然后就是构建一个骨架了。\n拿上面这个例子来说，在你敲击回车那一刻，骨架要帮做很多args解析的事情，然后构建对应任务处理。\n这张图就是当程序监听到命令行有输入操作的时候要做的事情，我把他抽象画成了一个图，大部分程序员应该能看得懂，看不懂可以对照仓库代码看看，虽然代码写的一坨，很low代码，毕竟还只是刚刚入坑Rust。。。。新手朋友可以看看，对了有启发或者帮助记得留一个star！\n   仓库   https://github.com/auula/falsework  ","date":"Sep 16","permalink":"http://blog.ibyte.me/post/rust-falsework-desgin/","tags":null,"title":"Rust Falsework Desgin"},{"categories":null,"contents":"相信大家在开发的过程中经常会使用到go中并发利器channel，channel 是CSP并发模型中最重要的一个组件，两个独立的并发实体通过共享的通讯channel进行通信。大多数人只是会用这么个结构很少有人讨论它底层实现，这篇文章讲写写channel的底层实现。\n   channel  channel的底层实现是一个结构体，源代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  type hchan struct { qcount uint // total data in the queue  dataqsiz uint // size of the circular queue  buf unsafe.Pointer // points to an array of dataqsiz elements  elemsize uint16 closed uint32 elemtype *_type // element type  sendx uint // send index  recvx uint // receive index  recvq waitq // list of recv waiters  sendq waitq // list of send waiters  // lock protects all fields in hchan, as well as several  // fields in sudogs blocked on this channel.  //  // Do not change another G\u0026#39;s status while holding this lock  // (in particular, do not ready a G), as this can deadlock  // with stack shrinking.  lock mutex }   可能看源代码不是很好看得懂，这里我个人画了一张图方便大家查看，我在上面标注了不同颜色，并且注释其作用。\n通道像一个传送带或者队列，总是遵循FIFO的规则，保证收发数据的顺序，通道是goroutine间重要通信的方式，是并发安全的。\n   buf  hchan结构体中的buf指向一个循环队列，用来实现循环队列，sendx是循环队列的队尾指针，recvx是循环队列的队头指针，dataqsize是缓存型通道的大小，qcount是记录通道内元素个数。\n在日常开发过程中用的最多就是ch := make(chan int, 10)这样的方式创建一个通道，如果这要声明初始化的话，这个通道就是有缓冲区的，也是图上紫色的buf，buf是在make的时候程序创建的，它有元素大小*元素个数组成一个循环队列，可以看做成一个环形结构，buf则是一个指针指向这个环。\n上图对应的代码那就是ch = make(chan int,6)，buf指向这个环在heap上的地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe.  if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.  // buf points into the same allocation, elemtype is persistent.  // SudoG\u0026#39;s are referenced from their owning thread so they can\u0026#39;t be collected.  // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.  var c *hchan switch { case mem == 0: // Queue or element size is zero.  c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization.  c.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers.  // Allocate hchan and buf in one call.  c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers.  c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) if debugChan { print(\u0026#34;makechan: chan=\u0026#34;, c, \u0026#34;; elemsize=\u0026#34;, elem.size, \u0026#34;; dataqsiz=\u0026#34;, size, \u0026#34;\\n\u0026#34;) } return c }   上面就是对应的代码实现，上来它会检查你一系列参数是否合法，然后在通过mallocgc在内存开辟这块空间，然后返回。\n   sendx and recvx  下面我手动模拟一个ring实现的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Queue cycle buffer type CycleQueue struct { data []interface{} // 存放元素的数组，准确来说是切片  frontIndex, rearIndex int // frontIndex 头指针,rearIndex 尾指针  size int // circular 的大小 } // NewQueue Circular Queue func NewQueue(size int) (*CycleQueue, error) { if size \u0026lt;= 0 || size \u0026lt; 10 { return nil, fmt.Errorf(\u0026#34;initialize circular queue size fail,%d not legal,size \u0026gt;= 10\u0026#34;, size) } cq := new(CycleQueue) cq.data = make([]interface{}, size) cq.size = size return cq, nil } // Push add data to queue func (q *CycleQueue) Push(value interface{}) error { if (q.rearIndex+1)%cap(q.data) == q.frontIndex { return errors.New(\u0026#34;circular queue full\u0026#34;) } q.data[q.rearIndex] = value q.rearIndex = (q.rearIndex + 1) % cap(q.data) return nil } // Pop return queue a front element func (q *CycleQueue) Pop() interface{} { if q.rearIndex == q.frontIndex { return nil } v := q.data[q.frontIndex] q.data[q.frontIndex] = nil // 拿除元素 位置就设置为空  q.frontIndex = (q.frontIndex + 1) % cap(q.data) return v }   循环队列一般使用空余单元法来解决队空和队满时候都存在font=rear带来的二义性问题，但这样会浪费一个单元。golang的channel中是通过增加qcount字段记录队列长度来解决二义性，一方面不会浪费一个存储单元，另一方面当使用len函数查看队列长度时候，可以直接返回qcount字段，一举两得。\n当我们需要读取的数据的时候直接从recvx指针上的元素取，而写就从sendx位置写入元素，如图：\n   sendq and recvq  当写入数据的如果缓冲区已经满或者读取的缓冲区已经没有数据的时候，就会发生协程阻塞。\n如果写阻塞的时候会把当前的协程加入到sendq的队列中，直到有一个recvq发起了一个读取的操作，那么写的队列就会被程序唤醒进行工作。\n当缓冲区满了所有的g-w则被加入sendq队列等待g-r有操作就被唤醒g-w，继续工作，这种设计和操作系统的里面thread的5种状态很接近了，可以看出go的设计者在可能参考过操作系统的thread设计。\n当然上面只是我简述整个个过程，实际上go还做了其他细节优化，sendq不为空的时候，并且没有缓冲区，也就是无缓冲区通道，此时会从sendq第一个协程中拿取数据，有兴趣的gopher可以去自己查看源代码，本文也是最近笔者在看到这块源代码的笔记总结。\n","date":"Sep 16","permalink":"http://blog.ibyte.me/post/golang-channel-desgin/","tags":null,"title":"Golang Channel Desgin"},{"categories":null,"contents":"   前 言  很多时候为了更快的开发效率，大多数程序员都是在使用抽象层级更高的技术，包括语言，框架，设计模式等。所以导致很多程序员包括我自己在内对于底层和基础的知识都会有些生疏和，但是正是这些底层的东西构建了我们熟知的解决方案，同时决定了一个技术人员的上限。\n在写C和C++的时候动态分配内存是让程序员自己手动管理，这样做的好处是，需要申请多少内存空间可以很好的掌握怎么分配，但是如果忘记释放内存，则会导致内存泄漏。\nRust又比👆上面俩门语言分配内存方式显得不同，Rust的内存管理主要特色可以看做是编译器帮你在适当的地方插入delete来释放内存，这样一来你不需要显式指定释放，runtime也不需要任何GC，但是要做到这点，编译器需要能分析出在什么地方delete，这就需要你代码按照其规则来写了。\n相比上面几种的内存管理方式的语言，像Java和Golang在语言设计的时候就加入了garbage collection也就runtime中的gc，让程序员不需要自己管理内存，真正解放了程序员的双手，让我们可以专注于编码。\n   函数栈帧  当一个函数在运行时，需要为它在堆栈中创建一个栈帧（stack frame）用来记录运行时产生的相关信息，因此每个函数在执行前都会创建一个栈帧，在它返回时会销毁该栈帧。\n通常用一个叫做栈基址（bp）的寄存器来保存正在运行函数栈帧的开始地址，由于栈指针（sp）始终保存的是栈顶的地址，所以栈指针保存的也就是正在运行函数栈帧的结束地址。\n销毁时先把栈指针（sp）移动到此时栈基址（bp）的位置，此时栈指针和栈基址都指向同样的位置。\n   Go内存逃逸  可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。下面来看看一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import \u0026#34;fmt\u0026#34; func main() { f := foo(\u0026#34;Ding\u0026#34;) fmt.Println(f) } type bar struct { s string } func foo(s string) bar { f := new(bar) // 这里的new(bar)会不会发生逃逸？？？  defer func() { f = nil }() f.s = s return *f }   我想很多人认为发生了逃逸，但是真的是这样的吗？那就用go build -gcflags=-m escape/struct.go看看会输出什么？？？\n其实没有发生逃逸，而escape/struct.go:7:13: f escapes to heap的逃逸是因为动态类型逃逸，fmt.Println(a …interface{})在编译期间很难确定其参数的具体类型，也能产生逃逸。\n继续看下面这一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import \u0026#34;fmt\u0026#34; func main() { f := foo(\u0026#34;Ding\u0026#34;) fmt.Println(f) } type bar struct { s string } func foo(s string) *bar { f := new(bar) // 这里的new(bar)会不会发生逃逸？？？  defer func() { f = nil }() f.s = s return f }   f := new(bar)会发生逃逸吗？\n1 2 3 4 5 6 7 8 9  $: go build -gcflags=-m escape/struct.go # command-line-arguments escape/struct.go:16:8: can inline foo.func1 escape/struct.go:7:13: inlining call to fmt.Println escape/struct.go:14:10: leaking param: s escape/struct.go:15:10: new(bar) escapes to heap ✅ escape/struct.go:16:8: func literal does not escape escape/struct.go:7:13: []interface {}{...} does not escape \u0026lt;autogenerated\u0026gt;:1: .this does not escape   Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，虽然在函数 foo() 内部 f 为局部变量，其值通过函数返回值返回，f 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。\n那就继续往下看吧，看看这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main func main() { Slice() // ？？？ 会发生逃逸吗？ } func Slice() { s := make([]int, 10000, 10000) for index, _ := range s { s[index] = index } }   估计很多人会回答没有，其实这里发生逃逸，实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。\n最后一个例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { Println(string(*ReverseA(\u0026#34;Ding Ding\u0026#34;))) // ??? } func Println(str string) { io.WriteString(os.Stdout, str+\u0026#34;\\n\u0026#34;) } func ReverseA(str string) *[]rune { result := make([]rune, 0, len(str)) for _, v := range []rune(str) { v := v defer func() { result = append(result, v) }() } return \u0026amp;result }   如果一个变量被取地址，通过函数返回指针值返回，还有闭包，编译器不确定你的切片容量时，是否要扩容的时候，放到堆上，以致产生逃逸。\n于是我优化了一下代码，再看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { result := []rune(\u0026#34;Ding Ding\u0026#34;) ReverseB(result) Println(string(result)) } func ReverseB(runes []rune) { for i, j := 0, len(runes)-1; i \u0026lt; j; i, j = i+1, j-1 { runes[i], runes[j] = runes[j], runes[i] } } func Println(str string) { io.WriteString(os.Stdout, str+\u0026#34;\\n\u0026#34;) }      如何得知变量是怎么分配？   引用 (golang.org) FAQ官方说的：\n 准确地说，你并不需要知道，Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上， 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。\n   小 结   逃逸分析的好处是为了减少gc的压力 栈上分配的内存不需要gc处理 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。  ","date":"Sep 16","permalink":"http://blog.ibyte.me/post/golang-memory-escape-analysis/","tags":null,"title":"Golang Memory Escape Analysis"},{"categories":["syntax"],"contents":"Lorem ipsum dolor sit amet1 consectetur adipisicing elit. Nemo tempora eum cumque neque voluptatum, odit ipsum consequatur animi.\nLorem ipsum dolor sit amet consectetur adipisicing elit. Nemo tempora eum cumque neque voluptatum, odit ipsum2 consequatur animi.\nLorem ipsum dolor sit amet consectetur adipisicing elit. Nemo tempora eum cumque neque voluptatum, odit ipsum consequatur animi.\nLorem ipsum dolor sit amet consectetur adipisicing elit. Nemo tempora eum cumque neque voluptatum, odit ipsum consequatur animi.\n  Test Footnote \u0026#x21a9;\u0026#xfe0e;\n Test Footnote2 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"May 31","permalink":"http://blog.ibyte.me/post-copy/footnote/","tags":null,"title":"Footnote test"},{"categories":["math"],"contents":"The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\n1  Inline math: $\\varphi=\\dfrac{1+\\sqrt5}{2}=1.6180339887… $   Inline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\n1 2 3  Block math: $$\\varphi=1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$   Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"May 22","permalink":"http://blog.ibyte.me/post-copy/test-katex/","tags":null,"title":"Katex support"},{"categories":["math"],"contents":"The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable MathJax in the config file by setting the mathjax param to true. This will import the necessary MathJax CSS/JS.\n1  Inline math: $\\varphi=\\dfrac{1+\\sqrt5}{2}=1.6180339887… $   Inline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\n1 2 3  Block math: $$\\varphi=1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$   Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"May 22","permalink":"http://blog.ibyte.me/post-copy/test-mathjax/","tags":null,"title":"MathJax support"},{"categories":null,"contents":"","date":"Nov 26","permalink":"http://blog.ibyte.me/articles/","tags":null,"title":"Articles"},{"categories":["themes","syntax"],"contents":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n   Headings  The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\n   H1     H2     H3     H4     H5     H6     Paragraph  Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\n   Blockquotes  The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\n   Blockquote without attribution   Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n    Blockquote with attribution   Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n    Tables  Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23       Inline Markdown within tables     Italics Bold Code     italics bold code       Code Blocks     Code block with backticks  1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;      Code block indented with four spaces  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;     Code block with Hugo\u0026amp;rsquo;s internal highlight shortcode  1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;      List Types     Ordered List   First item Second item Third item     Unordered List   List item Another item And another item     Nested list   Fruit  Apple Orange Banana   Dairy  Milk Cheese       Other Elements — abbr, sub, sup, kbd, mark  GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"Mar 11","permalink":"http://blog.ibyte.me/post-copy/markdown-syntax/","tags":["markdown","css","html"],"title":"Markdown Syntax Guide"},{"categories":null,"contents":"   Nya nya nyan meow meow mama  More napping, more napping all the napping is exhausting stretch out on bed you are a captive audience while sitting on the toilet, pet me slap the dog because cats rule bleghbleghvomit my furball really tie the room together always hungry. Humans,humans, humans oh how much they love us felines we are the center of attention they feed, they clean miaow then turn around and show you my bum. Cats secretly make all the worlds muffins slap owner\u0026rsquo;s face at 5am until human fills food dish, milk the cow hunt by meowing loudly at 5am next to human slave food dispenser throwup on your pillow. Get scared by doggo also cucumerro .\n   Cat is meow meow  Sees bird in air, breaks into cage and attacks creature when in doubt, wash spend six hours per day washing, but still have a crusty butthole yet lick sellotape tickle my belly at your own peril i will pester for food when you\u0026rsquo;re in the kitchen even if it\u0026rsquo;s salad find box a little too small and curl up with fur hanging out.\nClaw at curtains stretch and yawn nibble on tuna ignore human bite human hand. Under the bed mice yet funny little cat chirrup noise shaking upright tail when standing next to you but white cat sleeps on a black shirt for eat an easter feather as if it were a bird then burp victoriously.\n   Has closed eyes but still sees you present belly  scratch hand when stroked for is good you understand your place in my world get scared by sudden appearance of cucumber. What the heck just happened, something feels fishy chew master\u0026rsquo;s slippers yet brown cats with pink ears bite the neighbor\u0026rsquo;s bratty kid cereal boxes make for five star accommodation but i like to spend my days sleeping and eating fishes that my human fished for me we live on a luxurious yacht, sailing proudly under the sun, i like to walk on the deck, watching the horizon, dreaming of a good bowl of milk. Lounge in doorway put butt in owner\u0026rsquo;s face, or ptracy destroy house in 5 seconds. Mrow no, you can\u0026rsquo;t close the door, i haven\u0026rsquo;t decided whether or not i wanna go out is good you understand your place in my world.\nBrown cats with pink ears shred all toilet paper and spread around the house being gorgeous with belly side up. Cats go for world domination the best thing in the universe is a cardboard box cats are cute so meow all night having their mate disturbing sleeping humans. Nya nya nyan annoy owner until he gives you food say meow repeatedly until belly rubs, feels good eat the fat cats food but meowing non stop for food. Pet right here, no not there, here, no fool, right here that other cat smells funny you should really give me all the treats because i smell the best and omg you finally got the right spot and i love you right now see brother cat receive pets, attack out of jealousy. Headbutt owner\u0026rsquo;s knee love blinks and purr purr purr purr yawn for stand in front of the computer screen, or mew mew for human is washing you why halp oh the horror flee scratch hiss bite.\n   Cats making all the muffins  Cats making all the muffins asdflkjaertvlkjasntvkjn (sits on keyboard) so the dog smells bad but cough hairball on conveniently placed pants and show belly but loved it, hated it, loved it, hated it catch mouse and gave it as a present. Give me attention or face the wrath of my claws meow all night for love me! and love you, then bite you or mesmerizing birds. Lick human with sandpaper tongue. Murf pratt ungow ungow scratch the box sit in box and to pet a cat, rub its belly, endure blood and agony, quietly weep, keep rubbing belly wake up human for food at 4am or eat owner\u0026rsquo;s food trip owner up in kitchen i want food. Curl up and sleep on the freshly laundered towels paw at your fat belly, steal mom\u0026rsquo;s crouton while she is in the bathroom yet nyan nyan goes the cat, scraaaaape scraaaape goes the walls when the cat murders them with its claws milk the cow suddenly go on wild-eyed crazy rampage toy mouse squeak roll over.\nHunt by meowing loudly at 5am next to human slave food dispenser hate dog reward the chosen human with a slow blink. Cat dog hate mouse eat string barf pillow no baths hate everything miaow then turn around and show you my bum love fish, and kitty scratches couch bad kitty steal the warm chair right after you get up kitty poochy munch on tasty moths. Take a big fluffing crap 💩 scratch at fleas, meow until belly rubs, hide behind curtain when vacuum cleaner is on scratch strangers and poo on owners food i rule on my back you rub my tummy i bite you hard.\nThanks by cats.\n","date":"Mar 09","permalink":"http://blog.ibyte.me/post-copy/example-lazy-load-image/","tags":["markdown","text","image"],"title":"Example Lazy Load Image"},{"categories":null,"contents":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et     Vagus elidunt  \nThe Van de Graaf Canon\n   Mane refeci capiebant unda mulcebat  Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"Mar 09","permalink":"http://blog.ibyte.me/post-copy/placeholder-text/","tags":["markdown","text"],"title":"Placeholder Text"},{"categories":null,"contents":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }  ","date":"Mar 05","permalink":"http://blog.ibyte.me/post-copy/emoji-support/","tags":["emoji"],"title":"Emoji Support"}]