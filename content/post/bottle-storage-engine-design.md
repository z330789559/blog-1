---
title: "Bottle Storage Engine Design"
date: 2022-02-20T18:51:18+08:00
---

## 什么是Bottle？

> 首先要说明的是`Bottle`是一款`KV`嵌入式存储引擎，并非是一款`KV`数据库，我知道很多人看到了`KV`认为是数据库，当然不是了，很多人会把这些搞混淆掉，`KV`存储可以用来存储很多东西，而并非是数据库这一领域。可以这么理解数据库是一台汽车，那么`Bottle`是一台车的发动机。可以简单理解`Bottle`是一个对操作系统文件系统的`KV`用户态抽象化封装，可以基于`Bottle`做为存储层，在`Bottle`层之上封装一些数据结构和对外服务的存储协议就可以实现一个数据库。

![层次结构](https://tva1.sinaimg.cn/large/e6c9d24egy1gzfrmt7qo4j21c20u0tai.jpg)

为什么叫`Bottle`？我觉得这个项目的主要的功能就是存储，存储？存储不就是可以装东西，存储数据，所以我就联想到了`魔瓶`这个词，于是我想到了`Klein Bottle`，克莱因瓶如果是搞数学的应该很熟悉，克莱因瓶可以从一个平面达到另外一个平面，所以我就选择`Bottle`作为存储引擎的名字。

## 存储模型：日志结构合并树

`Bottle`采用的是类似于`lsm tree`数据结构，也就是`LSM-Tree`，全称`Log Structured-Merge Tree`，这种存储结构特点就是每条数据记录都是以顺序写的方式追加，我相信大家都用过各个语言里面日志记录包，这个存储模型也是类似于这样的，记录就和打印日志一样记录到数据存储文件中，这种顺序写的方式能充分发挥磁盘`IO`性能。


![性能对比](https://tva1.sinaimg.cn/large/e6c9d24egy1gzk6ej82y1j208c07ft8w.jpg)

这个数据文件组织结构最早应用有`Google`的`BigTable`，`Facebook Cassandra`当然目前属于`Apache`了， `LevelDB`这些存储项目上。

> `LSM`的理论是：在内存足够大的时候，每次写入的数据被先零时放置在内存中，因此不需要每次有数据更新就必须将数据写入到磁盘中，因此可以先将最新的数据驻留在内存中，等到积累到最后多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾。

![lsm读写流程](https://tva1.sinaimg.cn/large/e6c9d24egy1gzj7hokxhpj219x0u00vn.jpg)

1. 写入流程就是：先将操作通过日志追加的方式写入到`wal`里面，这个是防止宕机数据恢复使用，然后将写入的数据存储到内存的`memtable`中，该表的实现可以是红黑树或者跳跃表，这种可以方便范围查找。

2. 数据整理：当`memtable`达到内存阈值的时候，会将该部分数据形成快照，并新生产一个`memtable`用来处理后续的请求，在磁盘的`sstable`分了几个层级，被写满的的`memtable`将会和这些`sstable`层进行合并，每层的`sstable`达到阈值的时候也会不断的向下合并，在这个过程中就是在清除掉被标记删除掉的数据。

3. 查询过程：先查询`memtable`以及`immutable memtable`，找到就返回毕竟内存中是最新的记录，如果没有找到，那么就一层一层得往下查找到数据为止，这个过程有点像你把你一堆书叠起来，找一本你要的书，你只能从最上层往下面查找，知道找到或者找不到进行返回。

> 看完我写的这个流程，很明显`lsm`的特点就是对写友好，但是会存在磁盘文件占用不断加大问题，需要定期合并清理，但是查找的性能就一般了，如果数据比较新还好，如果写入的比较久，那么不能像`B+Tree`那样找一次就能确定，很有可能要不断的下推查找，可以使用`Bloom filter`进行友化，在查询的时候先经过布隆过滤器。


## Bottle存储模型设计

看完上面的`lsm tree`的设计，有没有什么办法在写和读方面做到平衡呢，也就是写性能也快，读性能也快，能不能读取的时候只经过一次索引查找就能定位到数据所存在的文件呢？然后一次`io`操作就就读取到数据呢？

我想大家都了解过数据结构吧，数据结构里面什么结构在大数据量下查询速度最快呢？如果我说基于散列算法的哈希表，应该没有人反对吧，只要你的散列算法和你的散列槽位，和扩容策略设计的够好，我相信性能也不会太差。

> 其实我们所说的这个`kv`存储，其实这个`key`是不是相当于我们常用的编程语言里面的`map`的键，然后`value`的就是存储方式不同了，结合上面的`lsm tree`的特征，我们是不是可以优化一下，或者说重新设计一下，把索引换成基于散列算法的索引，通过散列计算得到`value`的位置呢？

这方面存储引擎设计，已经有前人做过尝试并且应用，`Riak`这个数据库就是基于以上想法，设计一个`bitcask`存储模型，他们设计论文有：

- [https://riak.com/assets/bitcask-intro.pdf](https://riak.com/assets/bitcask-intro.pdf)

`Bottle`的实现就是基于这篇论文里面所提出的存储解决方案，一个`Bottle`的实例其实就是一个目录，`Bottle`那个进程会对这个目录有操作所有权，在任何时候都只有一个文件是`active`状态用于被主线程来写入数据记录。

当`active`文件达到空间阈值它将被关闭，然后一个新的文件设置为`active`继续接收新的写入请求，被关闭的文件状态被设置为只读并且把操作系统的文件句柄在内存里面添加对应映射，方便后面数据查询读取使用。

![一个Bottle实例](https://tva1.sinaimg.cn/large/e6c9d24egy1gzjby5wxv3j219e0u0gnt.jpg)

这里我就不讲废话了，如果对`bitcask`工作原理感兴趣的话，可以去查看这篇文章：[https://blog.ibyte.me/post/bitcask-kvbase/](https://blog.ibyte.me/post/bitcask-kvbase/)

## 索引怎么选？

如果读者看完我上面给出的链接里面的资料，你会发现，`索引`对存储的性能起到关键作用，数据的读取存储快慢，都依赖于索引，像目前采用的`bitcask`论文中说的基于散列定位的。

**读完它最大缺点就是索引数据全部在内存，设计内存数据索引结构时要考虑每一个索引和记录关系占用，然后计算预计系统整体数据的量占用的内存大小，然后索引数据要持久化，并且如果是基于散列索引那么不不支持范围扫描，如果要支持范围扫描可以考虑`Adaptive Radix Tree(自适应前缀树)`，或者跳表这样的结构做索引。**

索引有什么选择？

 - `Adaptive Radix Tree`
 - `Skip List`
 - `Hash Table`
 - `Adaptive Hash Index, AHI`
 

![不同结构对比](https://tva1.sinaimg.cn/large/e6c9d24egy1gzk5mvnwzej215a0cywft.jpg)


基数树这个在一些`web`路由框架里面用的比较多，文件目录啊，网站路径，做路由匹配的，当然也可以来搞存储索引，但是工作量代码量很大，也不轻量级。

- [github.com/gammazero/radixtree](github.com/gammazero/radixtree)


![基数树](https://tva1.sinaimg.cn/large/e6c9d24egy1gzk5ra5825j20m80dwdgy.jpg)

`radix tree`可以被认为是一棵简洁版的前缀树，拥有共同前缀的节点也共享同一个父节点，下面是一个`GET`方法对应的路由树的结构：

```go
Priority   Path             Handle
9          \                *<1>
3          ├s               nil
2          |├earch\         *<2>
1          |└upport\        *<3>
2          ├blog\           *<4>
1          |    └:post      nil
1          |         └\     *<5>
2          ├about-us\       *<6>
1          |        └team\  *<7>
1          └contact\        *<8>
```

`*<num>`是方法`handler`对应的指针，从根节点遍历到叶子节点我们就能得到完整的路由表，图中的示例实现了以下路由：

```go
GET("/", func1)
GET("/search/", func2)
GET("/support/", func3)
GET("/blog/", func4)
GET("/blog/:post/", func5)
GET("/about-us/", func6)
GET("/about-us/team/", func7)
GET("/contact/", func8)
```

怎么批量配，例如下面一个例子，我去访问我的仓库地址，`GitHub`服务器是怎么知道的我仓库的？ 例如：`github.com/auula/:repo`

`:repo`是真实的`:repo`的一个占位符（就是一个参数，这里体现了`radix tree`相较于`hash-map`的一个优点，树结构允许我们的路径中存在动态的部分`参数`。

**如果要支持范围搜索，那么基数树是一个很好选择，但是工作量代码量难度，远超于基于`Hash Table`的。**

## 脏数据合并怎么搞?

数据越来越多，怎么减少内存占用问题，怎么管理脏的数据记录？

1. 定时合并，依赖于标记删除
2. 那什么时候合并，合适？
3. 怎么合并数据？遇到了就删除操作的数据标记，就抛弃？
4. 什么时间合并，引入统计学的算法，去触发合并？