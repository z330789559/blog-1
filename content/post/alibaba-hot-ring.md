---
title: "Alibaba Hot Ring Perceive"
date: 2021-09-16T22:27:07+08:00
---

## 👨‍💻‍：直奔话题 HotRing，少说废话。

> 去年阿里的`Tair`团队发表过一篇论文`HotRing: A Hotspot-Aware In-Memory Key-Value Store`，这篇论文里面讲述了阿里的最快的`KV`分布式存储引擎核心`HotRing`的技术与实现，我看了他们的数据显示其引擎吞吐性能可达`600M ops/s`，这个速度比传统的`KVS`系统`2.58`倍的性能提升，于是我就抱着好奇去看看了那篇论文然后就有这篇文章。

## 👨‍💻‍： 有问题就有故事？

一个新东西或者技术出现，那就说明老的那套方案技术存在某种缺陷或者满足不了`某种`的特殊需求了......

问题动机就是：某一时刻流量上来了，系统扛不住了...  只要说到高并发，相信这个回答占大多数。`HotRing`的出现也是这个原因，真的是`面向问题编程`😜。。。挖槽，真的验证这句话了。。。



![传统的kvs](https://tva1.sinaimg.cn/large/008i3skNgy1guiu9ot0gyj60u00j5wg302.jpg)

这张图就是传统的`kvs`架构图，不管你中间的那一层用什么，在某些时刻，缓存系统迎来巨大的访问量（`双11秒杀`），可能存在`访问倾斜`(`什么？你问我什么是访问倾斜，好吧你不适合编程。😜`)，大多数访问集中在极少数数据上（例如`微博热点事件`）。

对于集群级别的热点监测倍受重视，如`一致性 Hash`，某个节点上的数据被读写访问次数远远高出其他节点，对此类行为没有很好的监测到。

还有单机热问题上没有优化，例如计算机内存的`KV`存储热点和查询速度没有优化。


![存储金字塔](https://tva1.sinaimg.cn/large/008i3skNgy1guiua7v46yj60u00ifgo402.jpg)

一个好的存储这些事情都是必须去做的，从上到下，从下到上，每层都在解决一部分问题，总和就是一个大的问题，如果你不能把问题拆成小问题，那你那个问题不一定能解决的好，例如`CPU Cache、LevelDB`的设计。

## 👨‍💻‍：HotRing 干了什么？？？
现有技术，内存 `KVS` 对时延要求是很高的，一个在并发中无锁的数据结构尤为重要，然后就是一个能让热点数据能自我跑到最容易访问的地方提高读取速度的。

1. 热点是动态变化的，如何检测，如何转移?

这个问题是逃不开的，在`HotRing`的设计，论文中提到了一个概念就是`有序环`。

![Hotring](https://tva1.sinaimg.cn/large/008i3skNgy1guiuap7e6rj61780hqdhu02.jpg)

它做了什么？看得懂上图就能看出来，他把传统的`Map`的底层的存储`链表+数组`结构换成了一个`环形链结构`，然后通过`head`自由的控制指向哪一个节点。


![head指针](https://tva1.sinaimg.cn/large/008i3skNgy1guiuby6kl8j615a0higmd02.jpg)

传统的结构可能你的数据在最后一层或者数据非常多，程序只能通过`head`顺序查找，时间复杂度`O(n)`

而环形的结构，避免多次遍历希望把热点数据放在冲突链前面，传统的则需要不断修改节点，需要不断移动节点，必须从头节点开始，到尾节点终止。移动头指针的情况下，会导致一些节点无法被访问。



![传统](https://tva1.sinaimg.cn/large/008i3skNgy1guiuch2mb8j60nc06amx902.jpg)

移动热点不方便，需要把中间节点移动到头节点去，移动链表中的节点很复杂且难以做到无锁并发，就上图这个操作就要3步。

改成环链，`Head`可以指向任意节点，即从任意节点开始遍历，然后还能对数据进行排序。


![为什么有序](https://tva1.sinaimg.cn/large/008i3skNgy1guiucst2v1j611g0h6q4o02.jpg)

2. 为什么有序???

这个就属于环链的特点了，没有终结点，如果查找值不存在，无法判断何时终结。改成有序的了，可以根据前后项的关系判断是否终结本次查询。

![推导数学公式](https://tva1.sinaimg.cn/large/008i3skNgy1guiud5dossj60ls09qt9602.jpg)

- 前驱节点 < 待查找节点 <后驱节点 miss
- 前驱节点 > 后驱节点 && 待查找节点 < 后驱节点 miss
- 前驱节点 > 后驱节点  && 待查找节点 > 前驱节点 miss
- 待查找节点 == 节点 K hit


排序的过程就是利用`key`排序可以解决这个问题，若目标`key`介于连续两个`item`的`key`之间，说明为`read miss`操作，即可终止返回。由于实际系统中，数据`key`的大小通常为`10~100B`，比较会带来巨大的开销。哈希结构利用`tag`来减少`key`的比较开销。


![结构图](https://tva1.sinaimg.cn/large/008i3skNgy1guiug961wuj60mj0gc3z102.jpg)

`tag`是哈希值的一部分，每个`key`计算的哈希值，前k位用来哈希表的定位，后n-k位作为冲突链中进一步区分`key`的标志。为了减小排序开销，我们构建字典序：`order = (tag, key)`，先根据`tag`进行排序，`tag`相同再根据`key`进行排序。

![对比图](https://tva1.sinaimg.cn/large/008i3skNgy1guiufzy0kqj60u00lsac102.jpg)


有了这些条件，`HotRing`就是可控的了。

## 🔥：热点数据跟踪


由于在不同的时间里，热点数据都是不停变化的，可能`t1-t2`这个时间段热的数据可能是在`n1`节点上，在`t`段数据后有发生了变化在`n2`节点上。

**热点识别转移有两种策略：**

1. 随机移动策略，效率高、效果可能差（不需要采样、计算，响应速度快），例如第`R`次访问如果是 `Hot Access`，保持不变，如果是 `Cold Access`，移动头指针指向冷数据，在热点集中时非常有效，头指针会趋向于指向热点数据，否则可能会频繁摇摆。

2. 统计采样策略，效率低、效果可能更好，索引格式有特殊要求如下图：



![内存布局](https://tva1.sinaimg.cn/large/008i3skNgy1guiudhc8ddj60u00dugmp02.jpg)

- 针对`RCU`更新操作的采样优化
- 热点继承防止冷启动
- 采样分析策略如何选出最优位置

内存指针分配`64bits`，`address` 实际使用了`48bits`，采样所需的元数据结构上面的图所示，分别在头指针处设置`Total Counter`，记录该环的访问总次数，每个`item`设置`Counter`记录该`item`的访问次数。因为内存指针需要分配`64bits`，但实际系统地址索引只使用其中的`48bits`。我们使用剩余`16bits`设置标志位(例如`Total Counter、Counter`等)，保证不会增加额外的元数据开销。该策略的优势是，通过采样分析，可以计算选出最优的头指针位置，稳态时性能表现更优。

**数据采样**


![推导公式](https://tva1.sinaimg.cn/large/008i3skNgy1guiuds67hfj60f803c3yg02.jpg)

我来解释一下公式，`k`= 有多少个节点，`ni`= 当前节点访问频率，`N`总的访问次数，`mod`计算出来的内存指针需要移动次数，然后就是`概率*访问的成本`，然后累加就知道访问得到热点数据的成本，最后就是`t`就是指针调整到的节点。

**为什么不是直接转移到  `max(ni)`?**

这个问题显然就是如果你直接调整到热节点位置，那么这个环路上不只是有一个热点数据节点，所有需要使用采用经过公式计算之后的。

- 写入密集型的热点：`RCU`
- `Read`读热点、`Update`写入密集型热点
- `Less Than 8Bytes -- CAS`
- `More Than 8Bytes -- RCU`
- 如果头指针指向的节点被 `Update`，给前驱节点 `Counter + 1`


## 🔐：无锁并发访问

`Tair`的`RCU`无锁引擎是`HotRing`的设计基础，因为没有对环形链表结构修改，所以不存在并发问题，可以直接不加锁访问。


![并发插入时数据丢失问题](https://tva1.sinaimg.cn/large/008i3skNgy1guiue7lo6lj60tu0uq0u702.jpg)

但是在并发插入时数据丢失问题，解决办法就是使用了`CompareAndSwap`，保证同时只有一个线程能够修改成功。

什么是`CompareAndSwap`? 通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过`CAS`操作将新值与旧值进行交换。如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时`CAS`操作将会成功执行 使内存中的数据变为新值。


![插入操作](https://tva1.sinaimg.cn/large/008i3skNgy1guiuf9g8d4j60u009ut9902.jpg)

`Update` 和 `Insertion` 并发引发的数据丢失，怎么看这个图，假设`B`为热点数据，程序每次找的`B`必须经过`A`，因为`A`在环路上是在`B`前面，那么`访问B多少次A就是多少次`，那么这个不是理想的，那就让`hard`指针指向`A`让`B`之间没有其他的值。

在链`A->B->D`上，线程`1`进行插入`C`的操作，同时线程`2`进行`RCU`更新`B`的操作，尝试更新为`B`'。线程`1`修改B的指针指向`C`，完成插入。而线程`2`修改`A`的指针指向`B`'完成更新。两个线程并发修改不同的内存，均可成功返回。但是这时遍历整条链`(A->B'->D)`，将发现`C`无法被遍历到，导致正确性问题。当线程`2`更新`B`时，首先需要将`B`的`Occupied`标志位置位。线程`1`插入`C`需要修改`B`的指针(`Next Item Address`)，若发现`Occupied`标志位已置位，则需要重新遍历链表，尝试插入，通过使并发操作竞争修改同一内存地址，保证并发操作的正确性，利用相同原理保证了头指针移动操作，与`CRUD`操作的并发正确性，因此实现了`HotRing`的无锁并发访问。

**更多细节自己去看论文吧，上面部分总结。**

## 论文资料
- https://www.usenix.org/system/files/fast20-chen_jiqiang.pdf