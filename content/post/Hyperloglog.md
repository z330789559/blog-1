---
title: "Hyperloglog"
date: 2021-10-25T14:18:04+08:00
---


![一张有趣的表情](https://tva1.sinaimg.cn/large/008i3skNgy1gvodsvv1xaj60o00maq4a02.jpg)

## Hyperloglog

上一篇文章[HLL基础部分](https://mp.weixin.qq.com/s/nBNnaP2i7lJV_vJzHN0zMg)介绍了`HLL`一些相关理论知识，里面的抛硬币游戏，硬币正反两面，如果用计算机里面的数据表示的话，完全可以使用`0`和`1`，`1`表示正面，`0`表示反面。

`HLL`常用于去重场景，`HLL` 算法需要完整遍历所有元素一次，而非多次或采样，算法`只能计算集合中有多少个不重复的元素`，不能给出每个元素的出现次数或是判断一个元素是否之前出现过，多个使用 `HLL` 统计出的`基数值`  可以融合。

![特性：数据变 内存不变](https://tva1.sinaimg.cn/large/008i3skNgy1gvp8dfx7ytj60sw0dq75102.jpg)

`HLL`的空间只会和精度有关，下面的后面不同的数字代表着不同的精度，数字越大，精度越高，占用的空间也越大。

![精度和空间变换](https://tva1.sinaimg.cn/large/008i3skNgy1gvp8ifcvrsj60sw0dqt9p02.jpg)


> 上一篇文章[HLL基础部分](https://mp.weixin.qq.com/s/nBNnaP2i7lJV_vJzHN0zMg)介绍了`HLL`一些相关理论知识，里面的抛硬币游戏，你非常幸运，第一次进行这个实验就连抛了 20 次正面，你进行了很多次这个实验才得到了这个记录，这就会导致错误的预估，改进的方式是请 `10` 位不同的人进行这项实验，这样就可以观察到更多的样本数据，降低出现上述情况的概率，这就是 `HLL` 算法的核心思想。

`HLL`实现原理的话，当输入一个元素的时候，会把元素通过`Jenkins hash function`（当然这里也可以用其他`hash`算法）转成哈希值然后再转换成`01`表示的二进制数据。

![转换过程](https://tva1.sinaimg.cn/large/008i3skNgy1gvpfp5wrgvj609w0dr3ym02.jpg)

有了`bit`位值后，里面的`0`和`1`就可以表示某个事件结果的两种状态，例如`正反面`。有这些就可以找出每个位串上第一个最晚`1`出现的位置并且记录下来，并且来根据这个`1`来估算这些哈希值中不重复的个数。

![要区分高低位](https://tva1.sinaimg.cn/large/008i3skNgy1gvpgzsunugj609w044dfo02.jpg)

例如有集合为`[010, 100, 001]`, 集合中元素的第一个 `1` 出现的位置分别为 `2, 1, 3`，可以得到里面最大的值为 `3`，故该集合中第一个`1`出现的最晚的位置为 `3`因为每个位置上出现`1`的概率都是 `1/2`，所以我们可以做一个简单的推断，该集合中有 `8` 个不重复的元素。

这种简单的推断计算出来集合的基数值是有较大的偏差，为了减少误差，`HLL` 通过多次的进行试验来减少误差，`HLL`设计者使用了分桶的思想。

![映射到桶](https://tva1.sinaimg.cn/large/008i3skNgy1gvpguk73qcj60t406ydg702.jpg)

如上图，该 `hash `值的后 `10` 位的 `bit` 值是 `0000001001`，转成十进制是 `9`，对应第` 9` 号桶，而该值第一个`1`出现的位置是第`6`位，比原先 `9`号桶中的数字大，故把 `9` 号桶中的数字更新为 `6`。

为什么是取后`10`位，这是是取决于结果的精确度，`HLL`算法的精度就越高，`HLL(10)` 有 `1024(2^10)` 个桶，`HLL(16)`有 `65536(2^16)` 个桶，桶的个数越多，所占用的空间也会越大。

其实我这里写的还是比较简单的，省略了一些细节，真实的 `HLL` 算法的完整描述见上图，这边的重点是计算桶中平均数时使用调和平均数，调和平均数的优点是可以过滤掉不健康的统计值，使用算术平均值容易受到极值的影响。

例如：求一个`Google L3员工和一个 Google L6 的评价工资`，如果使用传统的算法计算，计算两个相加然后/个数。

而调和平均数计算如下：

```rust
采用调和平均数的方式就是： 2/(1/1000 + 1/30000) ≈ 1935.484
```

## Redis

分桶过程：抽象到计算机存储中去，就是存储的是一个以单位是比特`(bit)`，长度为 `L` 的大数组 `S` ，将 `S` 平均分为 `m` 组，注意这个 `m` 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 `P`。

```go
L = S.length
L = m * p
以 K 为单位，S 占用内存 = L / 8 / 1024
```

在`Redis`中`HyperLogLog`设置为：`m=16834，p=6，L=16834 * 6`，所以占用内存为=`16834 * 6 / 8 / 1024 = 12K`。
