---
title: "Bernoulli Experiment"
date: 2021-10-25T14:15:01+08:00
---

## 一个关于统计学的问题
说`Hyperloglog`之前，我得先写一些它的由来。设想一下，某某地方举办了一场技术交流活动，工作人员需要统计一下这个活动当天有多少的人参加？这个需求就是一个简单的统计的需求，解决方法有很多种，例如：活动举办方在会场门口设置一个签到处，每来一个参会者记录一下，最后统计一下人数就可以了。这是一个很简单问题，当时某一天作为开发的我，接到一个来自产品需求，`要我统计一下在双十一1天内的某一个页面的UV（Unique Visitors）？`，那么问题来了？怎么解决？


了解这个问题之前先说一下`uv统计标准`：独立访客UV指不同的用户，通过互联网访问同一个网页或产品的独立触发用户数。

假设一个场景: 今天爸爸、妈妈、儿子三人通过三个账号访问了某宝网页，则`UV=3`，
这里需要提一点：独立`UV`是按浏览器`cookie`为依据。只要`cookie`不清楚，3个人在`0:00—24:00`内用同一个浏览器不同的账号登陆，只会算作一个`UV`。

如图3个不同账户但是通过同一台电脑的浏览器访问的，如果默认以`cookie`作为标准的话，没有清理`cookie`的话，那么只会算一个`uv`。

![uv访问记录](https://tva1.sinaimg.cn/large/008i3skNgy1gvn6plcne8j60gx0ab0t602.jpg)

那么有开发经验的肯定会说简单啊，用`hashmap`或者用`set`集合...看似是一个简单问题，问题虽不难，但当参与问题中的变量达到一定数量级的时候，再简单的问题都会变成一个难题。假设日活用户达到百万或千万以上级别的话，我们采用 `HashMap` 的做法，就会导致程序中占用大量的内存，并且都是在并行的操作记录，还可能要考虑锁颗粒度问题，显然有经验的老司机会直接否决🙅这种方案。

## HyperLogLog 

看了什么的问题，那有木有什么好的解决方案？ 有肯定是有的：`B+ tree`，`Bitmap`，在`redis`中就有造好的轮子的`HyperLogLog`概率数据结构算法，在`redis`中使用也就是`3`个`api`的事情：`pfadd`、`pfcount`、`pfmerge`。但是想深挖下去这个东西属实有点复杂，会涉及到一些数学上的东西，正好笔者我也看了看实现，顺便就写了这篇文章，`HyperLogLog`这个是由下面👇这个`肥宅`在他的论文中提出的，对可能这就是国外搞学术的大佬吧，不过可惜的是大佬在 `2011年3月22日`就去世了，不过他留下的`HyperLogLog`还是很值得研究的。

![Philippe Flajolet教授](https://tva1.sinaimg.cn/large/008i3skNgy1gvn7lmdwfaj605e0773yj02.jpg)

`HLL`的特点就是能花较低的内存占用统计海量的数据，但是缺点也有代码实现比较难，有一定的误差，如果要统计的`100%`的准确性，还是要考虑其他方案或者通过数学计算算出误差值（负载因子）。

在`redis`实现的`HyperLogLog`中能用`12k`内存就能统计`2^64`个数据，我表示很震撼。。。怎么做到的？？？

![](https://tva1.sinaimg.cn/large/008i3skNgy1gvn8x0umjvj60ck0b4aai02.jpg)

挖槽这是怎么做到的？看了一下那篇论文：[http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf](http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf)

![呵呵哈哈哈](https://tva1.sinaimg.cn/large/008i3skNgy1gvn95nc0o8j60k010jtbc02.jpg)

## 伯努利试验证明

在说`HLL`之前得先了解一下`伯努利试验`!

> 伯努利试验是数学概率论中的一部分内容，它的典故来源于抛硬币游戏。 实验的内容：在同一个条件下重复地、各次之间相互独立地进行的一种试验，但是实验的结果只要两种结果，每次实验结果只会是两种结果中一个，然后在相同条件下重复做`n`次的试验称为`n`次独立重复试验，独立性是只各次试验的结果不会受其他实验结果的影响。

次数较少的实验是没有意义的，只要当实验次数达到一定数量，就和微积分一样，短时间是看不出来差异的，但是如果把时间线拉长，那么差异就出来了。

![结果是？](https://tva1.sinaimg.cn/large/008i3skNgy1gvn9weyz9pg609o05ggp202.gif)

实验过程： 硬币拥有正反两面，一次的上抛至落下，最终出现正反面的概率各自都是`50%`，假设一直抛硬币，直到它出现正面为止，我们记录为一次完整的试验，间中可能抛了一次就出现了正面，也可能抛了`n`次才出现正面，不管抛出多少次，只要出现了正面，就记录为一次试验。

重复不断这个过程，假设这个多次为`n`次，就意味着出现了`n`次的正面。假设每次伯努利试验所经历了的抛掷次数为`k`，第一次伯努利试验，次数设为`k1`，以此类推，第`n`次对应的是`kn`，在实验过程中肯定会出现抛出`n`才能出现一次正面，那么称这个为`k_max`，代表抛了最多的次数。

经过反复实验得出结果：

1. `N`次实验抛出的次数不会大于`k_max`
2. `N`次实验最少有一次的次数是`k_max`

当有了这些结论之后，发现在`n`和`k_max`中存在估算关联：`n = 2^(k_max)`，当然需要大量的数据和实验次数证明，如果需要深入挖掘其中的奥秘，那么还会涉及到数学中的概率和统计的方法才能推导和验证这种关联关系。。。。

```go
第一次: 抛了3次出正面，此时 k=3，n=1
第二次: 抛了2次出正面，此时 k=2，n=2
第三次: 抛了6次出正面，此时 k=6，n=3
第n 次：抛了20次出正面，此时我们估算， n = 2^20
```

看上面的实验如果套用这个估算关系公式的话，那么结果是：上面例子中实验组数共3组，那么 `k_max = 6`，最终 `n=3`，我们放进估算公式中去，明显： `3 ≠ 2^6`不成立的，但是证明了数据次数越少，意义就不大，发挥不了作用，就存在一定的误差值。

通过上面一系列的推导，又会得出一个结论就是，如果我每轮实验的次数越多，那么结果偏差就会越小，但是还有有偏差的存在。那么可不可以搞一个多轮的次数测试，例如搞`1000`次，然后再去取`每轮的k_max`，然后把`k_max`平摊到轮数上，就能算出`n`。

但是结果还是有偏差的，那怎么办？可以通过少量的测试观察结果误差，适当用`修正因子`做计算提高准确率，然后又演进出了一种`LogLog`的估算公式：

![LogLog估算公式](https://tva1.sinaimg.cn/large/008i3skNgy1gvnavkzk30j60gu03c0sm02.jpg)

上面的`DVLL`对应的就是`n`，`constant`为修正因子具体值是不定的，自定义设置，可以通过少量的测试观察结果误差，`m`代表的是试验的轮数，头上有一横的R就是平均数：`(k_max_1 + ... + k_max_m)/m`。

## 小结
本文整理一下`LogLog`相关基础理论，但是没有写完，后面更新下篇文章会讲`redis`的`hll`具体实现细节，`HyperLogLog`是由`Loglog`优化改进过来的，所以本篇先写到这。
